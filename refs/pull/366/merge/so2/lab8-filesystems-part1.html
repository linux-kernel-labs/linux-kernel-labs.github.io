<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SO2 Lab 08 - File system drivers (Part 1) &mdash; The Linux Kernel  documentation</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/asciinema-player.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
      <script>
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/asciinema-player.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="SO2 Lab 09 - File system drivers (Part 2)" href="lab9-filesystems-part2.html" />
    <link rel="prev" title="SO2 Lab 07 - Block Device Drivers" href="lab7-block-device-drivers.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            The Linux Kernel
          </a>
              <div class="version">
                5.10.14
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Operating Systems 2</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="lec1-intro.html">SO2 Lecture 01 - Course overview and Linux kernel introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec2-syscalls.html">SO2 Lecture 02 - System calls</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec3-processes.html">SO2 Lecture 03 - Processes</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec4-interrupts.html">SO2 Lecture 04 - Interrupts</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec5-smp.html">SO2 Lecture 05 - Symmetric Multi-Processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec6-address-space.html">SO2 Lecture 06 - Address Space</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec7-memory-management.html">SO2 Lecture 07 - Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec8-filesystems.html">SO2 Lecture 08 - Filesystem Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec9-debugging.html">SO2 Lecture 09 - Kernel debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec10-networking.html">SO2 Lecture 10 - Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec11-arch.html">SO2 Lecture 11 - Architecture Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec12-virtualization.html">SO2 Lecture 12 - Virtualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab1-intro.html">SO2 Lab 01 - Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab2-kernel-api.html">SO2 Lab 02 - Kernel API</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab3-device-drivers.html">SO2 Lab 03 - Character device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab4-interrupts.html">SO2 Lab 04 - I/O access and Interrupts</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab5-deferred-work.html">SO2 Lab 05 - Deferred work</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab6-memory-mapping.html">SO2 Lab 06 - Memory Mapping</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab7-block-device-drivers.html">SO2 Lab 07 - Block Device Drivers</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">SO2 Lab 08 - File system drivers (Part 1)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#lab-objectives">Lab objectives</a></li>
<li class="toctree-l3"><a class="reference internal" href="#virtual-filesystem-vfs">Virtual Filesystem (VFS)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-general-file-system-model">The general file system model</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#superblock">superblock</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inode">inode</a></li>
<li class="toctree-l4"><a class="reference internal" href="#file">file</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dentry">dentry</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#register-and-unregister-filesystems">Register and unregister filesystems</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#functions-mount-kill-sb">Functions mount, kill_sb</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#superblock-in-vfs">Superblock in VFS</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-struct-super-block-structure">The <code class="docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span></code> structure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#superblock-operations">Superblock operations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#the-fill-super-function">The <code class="docutils literal"><span class="pre">fill_super()</span></code> function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#buffer-cache">Buffer cache</a></li>
<li class="toctree-l3"><a class="reference internal" href="#functions-and-useful-macros">Functions and useful macros</a></li>
<li class="toctree-l3"><a class="reference internal" href="#further-reading">Further reading</a></li>
<li class="toctree-l3"><a class="reference internal" href="#exercises">Exercises</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#myfs">myfs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#minfs">minfs</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lab9-filesystems-part2.html">SO2 Lab 09 - File system drivers (Part 2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab10-networking.html">SO2 Lab 10 - Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab11-arm-kernel-development.html">SO2 Lab 11 - Kernel Development on ARM</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab12-kernel-profiling.html">SO2 Lab 12 - Kernel Profiling</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign-collaboration.html">Collaboration</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign0-kernel-api.html">Assignment 0 - Kernel API</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign1-kprobe-based-tracer.html">Assignment 1 - Kprobe based tracer</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign2-driver-uart.html">Assignment 2 - Driver UART</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign3-software-raid.html">Assignment 3 - Software RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign4-transport-protocol.html">Assignment 4 - SO2 Transport Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign7-kvm-vmm.html">Assignment 7 - SO2 Virtual Machine Manager with KVM</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Lectures</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../lectures/intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/syscalls.html">System Calls</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/interrupts.html">Interrupts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/smp.html">Symmetric Multi-Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/address-space.html">Address Space</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/memory-management.html">Memory Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/fs.html">Filesystem Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/debugging.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/networking.html">Network Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/arch.html">Architecture Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/virt.html">Virtualization</a></li>
</ul>
<p class="caption"><span class="caption-text">Labs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../labs/infrastructure.html">Infrastructure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_modules.html">Kernel modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_api.html">Kernel API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/device_drivers.html">Character device drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/interrupts.html">I/O access and Interrupts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/deferred_work.html">Deferred work</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/block_device_drivers.html">Block Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/filesystems_part1.html">File system drivers (Part 1)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/filesystems_part2.html">File system drivers (Part 2)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/networking.html">Networking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/arm_kernel_development.html">Kernel Development on ARM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/memory_mapping.html">Memory mapping</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/device_model.html">Linux Device Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_profiling.html">Kernel Profiling</a></li>
</ul>
<p class="caption"><span class="caption-text">Useful info</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../info/vm.html">Virtual Machine Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/extra-vm.html">Customizing the Virtual Machine Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/contributing.html">Contributing to linux-kernel-labs</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Operating Systems 2</a></li>
      <li class="breadcrumb-item active">SO2 Lab 08 - File system drivers (Part 1)</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/so2/lab8-filesystems-part1.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="so2-lab-08-file-system-drivers-part-1">
<h1>SO2 Lab 08 - File system drivers (Part 1)<a class="headerlink" href="#so2-lab-08-file-system-drivers-part-1" title="Permalink to this headline">¶</a></h1>
<div class="section" id="lab-objectives">
<h2>Lab objectives<a class="headerlink" href="#lab-objectives" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li>acquiring knowledge about the Virtual Filesystem (VFS) in Linux and understanding concepts regarding 'inode', 'dentry', 'file', superblock and data block.</li>
<li>understanding the process of mounting a file system inside VFS.</li>
<li>knowledge regarding various file system types and understanding differences between file systems with physical support (on disk) and the ones without physical support.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="virtual-filesystem-vfs">
<h2>Virtual Filesystem (VFS)<a class="headerlink" href="#virtual-filesystem-vfs" title="Permalink to this headline">¶</a></h2>
<p>The Virtual Filesystem (also known as VFS) is a component of the kernel that handles all system calls related to files and file systems.
VFS is a generic interface between the user and a particular file system.
This abstraction simplifies the implementation of file systems and provides an easier integration of multiple file systems. This way, the implementation of a file system is accomplished by using the API provided by the VFS, and the generic hardware and I/O subsystem communication parts are handled by VFS.</p>
<p>From a functional point of view, file systems can be grouped into:</p>
<blockquote>
<div><ul class="simple">
<li>disk file systems (ext3, ext4, xfs, fat, ntfs, etc.)</li>
<li>network file systems (nfs, smbfs/cifs, ncp, etc.)</li>
<li>virtual filesystems (procfs, sysfs, sockfs, pipefs, etc.)</li>
</ul>
</div></blockquote>
<p>A Linux kernel instance will use VFS for the hierarchy (a tree) of directories and files.
A new file system will be added as a VFS subtree using the mount operation.
A file system is usually mounted from the environment for which it was built (from a block type device, from network, etc.).
In particular, however, the VFS can use a normal file as a virtual block device, so it is possible to mount disk file systems over normal files. This way, stacks of file systems can be created.</p>
<p>The basic idea of VFS is to provide a single file model that can represent files from any file system.
The file system driver is responsible for bringing to the common denominator.
This way the kernel can create a single directory structure that contains the entire system.
There will be a file system that will be the root, the rest being mounted in its various directories.</p>
</div>
<div class="section" id="the-general-file-system-model">
<h2>The general file system model<a class="headerlink" href="#the-general-file-system-model" title="Permalink to this headline">¶</a></h2>
<p>The general file system model, to which any implemented file system needs to be reduced, consists of several well-defined entities: <code class="xref c c-type docutils literal"><span class="pre">superblock</span></code>, <code class="xref c c-type docutils literal"><span class="pre">inode</span></code>, <code class="xref c c-type docutils literal"><span class="pre">file</span></code>, and <code class="xref c c-type docutils literal"><span class="pre">dentry</span></code>.
These entities are file system metadata (they contain information about data or other metadata).</p>
<p>Model entities interact using some VFS or kernel subsystems: dentry cache, inode cache, buffer cache.
Each entity is treated as an object: it has a associated data structure and a pointer to a table of methods. The induction of particular behavior for each component is done by replacing the associated methods.</p>
<div class="section" id="superblock">
<h3>superblock<a class="headerlink" href="#superblock" title="Permalink to this headline">¶</a></h3>
<p>The superblock stores the information needed for a mounted file system:</p>
<blockquote>
<div><ul class="simple">
<li>inode and blocks locations</li>
<li>file system block size</li>
<li>maximum filename length</li>
<li>maximum file size</li>
<li>the location of the root inode</li>
</ul>
</div></blockquote>
<div class="section" id="localization">
<h4>Localization:<a class="headerlink" href="#localization" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul class="simple">
<li>In the case of disk file systems, the superblock has a correspondent in the first block of the disk. (Filesystem Control Block).</li>
<li>In VFS, all superblocks of filesystems are retained in a list of structures of type <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span></code> and the methods in structures of type <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_operations</span></code>.</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="inode">
<h3>inode<a class="headerlink" href="#inode" title="Permalink to this headline">¶</a></h3>
<p>The inode (index node) keeps information about a file in the general sense (abstraction): regular file, directory, special file (pipe, fifo), block device, character device, link, or anything that can be abstracted as a file.</p>
<p>An inode stores information like:</p>
<blockquote>
<div><ul class="simple">
<li>file type;</li>
<li>file size;</li>
<li>access rights;</li>
<li>access or modify time;</li>
<li>location of data on the disk (pointers to disk blocks containing data).</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Usually, the inode does not contain the file name. The name is stored by the <code class="xref c c-type docutils literal"><span class="pre">dentry</span></code> entity. This way, an inode can have multiple names (hardlinks).</p>
</div>
<div class="section" id="localization-1">
<h4>Localization:<a class="headerlink" href="#localization-1" title="Permalink to this headline">¶</a></h4>
<p>Like the superblock, the <code class="xref c c-type docutils literal"><span class="pre">inode</span></code> has a disk correspondent.
The inodes on disk are generally grouped into a specialized area (inode area) separated from the data blocks area; In some file systems, the equivalents of the inodes are spread in the file system structure (FAT);
As a VFS entity, an inode is represented by the structure <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">inode</span></code> and by the operations with it defined in the structure <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">inode_operations</span></code>.</p>
<p>Each inode is generally identified by a number. On Linux, the <code class="docutils literal"><span class="pre">-i</span></code> argument of the <code class="docutils literal"><span class="pre">ls</span></code> command shows the inode number associated with each file:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">razvan@valhalla:~/school/so2/wiki$</span> ls -i
<span class="go">1277956 lab10.wiki  1277962 lab9.wikibak  1277964 replace_lxr.sh</span>
<span class="go">1277954 lab9.wiki   1277958 link.txt      1277955 homework.wiki</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="file">
<h3>file<a class="headerlink" href="#file" title="Permalink to this headline">¶</a></h3>
<p>File is the component of the file system model that is closest to the user.
The structure exists only as a VFS entity in memory and has no physical correspondent on disk.</p>
<p>While the inode abstracts a file on the disk, the file structure abstracts an open file.
From the point of view of the process, the file entity abstracts the file. From the point of view of the file system implementation, however, the inode is the entity that abstracts the file.</p>
<p>The file structure maintains information such as:</p>
<blockquote>
<div><ul class="simple">
<li>file cursor position;</li>
<li>file opening rights;</li>
<li>pointer to the associated inode (eventually its index).</li>
</ul>
</div></blockquote>
<div class="section" id="localization-2">
<h4>Localization:<a class="headerlink" href="#localization-2" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul class="simple">
<li>The structure <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file</span></code> is the associated VFS entity, and the structure <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file_operations</span></code> represents the operations associated with it.</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="dentry">
<h3>dentry<a class="headerlink" href="#dentry" title="Permalink to this headline">¶</a></h3>
<p>The dentry (directory entry) associates an inode with a file name.</p>
<p>Generally, a dentry structure contains two fields:</p>
<blockquote>
<div><ul class="simple">
<li>an integer that identifies the inode;</li>
<li>a string representing its name.</li>
</ul>
</div></blockquote>
<p>The dentry is a specific part of a path that can be a directory or a file. For example, for the path <code class="docutils literal"><span class="pre">/bin/vi</span></code>, dentry objects will be created for <code class="docutils literal"><span class="pre">/</span></code>, <code class="docutils literal"><span class="pre">bin</span></code>, and <code class="docutils literal"><span class="pre">vi</span></code> (a total of 3 dentry objects).</p>
<blockquote>
<div><ul class="simple">
<li>the dentry has a correspondent on the disk, but the correspondence is not direct because each file system keeps the dentries in a specific way</li>
<li>in VFS, the dentry entity is represented by the structure <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span></code> and the operations with it are defined in the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dentry_operations</span></code> structure.</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="register-and-unregister-filesystems">
<span id="registerunregistersection"></span><h2>Register and unregister filesystems<a class="headerlink" href="#register-and-unregister-filesystems" title="Permalink to this headline">¶</a></h2>
<p>In the current version, the Linux kernel supports about 50 file systems, including:</p>
<blockquote>
<div><ul class="simple">
<li>ext2/ ext4</li>
<li>reiserfs</li>
<li>xfs</li>
<li>fat</li>
<li>ntfs</li>
<li>iso9660</li>
<li>udf for CDs and DVDs</li>
<li>hpfs</li>
</ul>
</div></blockquote>
<p>On a single system, however, it is unlikely that there will be more than 5-6 file systems. For this reason, file systems (or, more correctly, file system types) are implemented as modules and can be loaded or unloaded at any time.</p>
<p>In order to be able to dynamically load / unload a file system module, a file system registration / deregistration API is required. The structure describing a particular file system is <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file_system_type</span></code>:</p>
<blockquote>
<div><blockquote>
<div><div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">file_system_type</span> <span class="p">{</span>
         <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
         <span class="kt">int</span> <span class="n">fs_flags</span><span class="p">;</span>
         <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">mount</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span>
                                   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
         <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">kill_sb</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
         <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
         <span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span> <span class="n">next</span><span class="p">;</span>
         <span class="k">struct</span> <span class="n">hlist_head</span> <span class="n">fs_supers</span><span class="p">;</span>
         <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">s_lock_key</span><span class="p">;</span>
         <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">s_umount_key</span><span class="p">;</span>
         <span class="c1">//...</span>
<span class="p">};</span>
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">name</span></code> is a string representing the name that will identify a file system (the argument passed to <code class="docutils literal"><span class="pre">mount</span> <span class="pre">-t</span></code>).</li>
<li><code class="docutils literal"><span class="pre">owner</span></code> is <code class="docutils literal"><span class="pre">THIS_MODULE</span></code> for file systems implemented in modules, and <code class="docutils literal"><span class="pre">NULL</span></code> if they are written directly into the kernel.</li>
<li>The <code class="docutils literal"><span class="pre">mount</span></code> function reads the superblock from the disk in memory when loading the file system. The function is unique to each file system.</li>
<li>The <code class="docutils literal"><span class="pre">kill_sb</span></code> function releases the super-block from memory.</li>
<li><code class="docutils literal"><span class="pre">fs_flags</span></code> specifies the flags with which the file system must be mounted. An example of such flag is <code class="docutils literal"><span class="pre">FS_REQUIRES_DEV</span></code> that specifies to VFS that the file system needs a disk (it is not a virtual file system).</li>
<li><code class="docutils literal"><span class="pre">fs_supers</span></code> is a list containing all the superblocks associated with this file system. Since the same file system can be mounted multiple times, there will be a separate superblock for each mount.</li>
</ul>
</div></blockquote>
<p>The <em>registration of a file system</em> into the kernel is generally performed in the module initialization function. For registration, the programmer will have to</p>
<blockquote>
<div><ol class="arabic simple">
<li>initialize a structure of type <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file_system_type</span></code> with the name, the flags, the function that implements the superblock reading operation and the reference to the structure that identifies the current module</li>
<li>call the <code class="xref c c-func docutils literal"><span class="pre">register_filesystem()</span></code> function.</li>
</ol>
</div></blockquote>
<p>When unloading the module, you must unregister the file system by calling the <code class="xref c c-func docutils literal"><span class="pre">unregister_filesystem()</span></code> function.</p>
<p>An example of registering a virtual file system is found in the code for <code class="docutils literal"><span class="pre">ramfs</span></code>:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">struct</span> <span class="n">file_system_type</span> <span class="n">ramfs_fs_type</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">name</span>           <span class="o">=</span> <span class="s">&quot;ramfs&quot;</span><span class="p">,</span>
        <span class="p">.</span><span class="n">mount</span>          <span class="o">=</span> <span class="n">ramfs_mount</span><span class="p">,</span>
        <span class="p">.</span><span class="n">kill_sb</span>        <span class="o">=</span> <span class="n">ramfs_kill_sb</span><span class="p">,</span>
        <span class="p">.</span><span class="n">fs_flags</span>       <span class="o">=</span> <span class="n">FS_USERNS_MOUNT</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_ramfs_fs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">once</span><span class="p">))</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">register_filesystem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ramfs_fs_type</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="functions-mount-kill-sb">
<span id="functionsmountkillsbsection"></span><h3>Functions mount, kill_sb<a class="headerlink" href="#functions-mount-kill-sb" title="Permalink to this headline">¶</a></h3>
<p>When mounting  the file system, the kernel calls the mount function defined within the structure <code class="xref c c-type docutils literal"><span class="pre">file_system_type</span></code>. The function makes a set of initializations and returns a dentry (the structure <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span></code>) that represents the mount point directory. Usually <code class="xref c c-func docutils literal"><span class="pre">mount()</span></code> is a simple function that calls one of the functions:</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-func docutils literal"><span class="pre">mount_bdev()</span></code>, which mounts a file system stored on a block device</li>
<li><code class="xref c c-func docutils literal"><span class="pre">mount_single()</span></code>, which mounts a file system that shares an instance between all mount operations</li>
<li><code class="xref c c-func docutils literal"><span class="pre">mount_nodev()</span></code>, which mounts a file system that is not on a physical device</li>
<li><code class="xref c c-func docutils literal"><span class="pre">mount_pseudo()</span></code>, a helper function for pseudo-file systems (<code class="docutils literal"><span class="pre">sockfs</span></code>, <code class="docutils literal"><span class="pre">pipefs</span></code>, generally file systems that can not be mounted)</li>
</ul>
</div></blockquote>
<p>These functions get as parameter a pointer to a function <code class="xref c c-func docutils literal"><span class="pre">fill_super()</span></code> that will be called after the superblock initialization to finish its initialization by the driver. An example of such a function can be found in the <code class="docutils literal"><span class="pre">fill_super</span></code> section.</p>
<p>When unmounting the file system, the kernel calls <code class="xref c c-func docutils literal"><span class="pre">kill_sb()</span></code>, which performs cleanup operations and invokes one of the functions:</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-func docutils literal"><span class="pre">kill_block_super()</span></code>, which unmounts a file system on a block device</li>
<li><code class="xref c c-func docutils literal"><span class="pre">kill_anon_super()</span></code>, which unmounts a virtual file system (information is generated when requested)</li>
<li><code class="xref c c-func docutils literal"><span class="pre">kill_litter_super()</span></code>, which unmounts a file system that is not on a physical device (the information is kept in memory)</li>
</ul>
</div></blockquote>
<p>An example for a file system without disk support is the <code class="xref c c-func docutils literal"><span class="pre">ramfs_mount()</span></code> function in the <code class="docutils literal"><span class="pre">ramfs</span></code> file system:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">ramfs_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">fs_type</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">mount_nodev</span><span class="p">(</span><span class="n">fs_type</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">ramfs_fill_super</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>An example for a file system from disk is the <code class="xref c c-func docutils literal"><span class="pre">minix_mount()</span></code> function in the <code class="docutils literal"><span class="pre">minix</span></code> file system:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">minix_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">fs_type</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
         <span class="k">return</span> <span class="n">mount_bdev</span><span class="p">(</span><span class="n">fs_type</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">minix_fill_super</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="superblock-in-vfs">
<h2>Superblock in VFS<a class="headerlink" href="#superblock-in-vfs" title="Permalink to this headline">¶</a></h2>
<p>The superblock exists both as a physical entity (entity on disk) and as a VFS entity (within the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span></code> structure).
The superblock contains only metainformation and is used to write and read metadata from the disk (inodes, directory entries).
A superblock (and implicitly the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span></code> structure) will contain information about the block device used, the list of inodes, a pointer to the inode of the file system root directory, and a pointer to the superblock operations.</p>
<div class="section" id="the-struct-super-block-structure">
<h3>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span></code> structure<a class="headerlink" href="#the-struct-super-block-structure" title="Permalink to this headline">¶</a></h3>
<p>Part of the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span></code> structure definition is presented below:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">super_block</span> <span class="p">{</span>
        <span class="c1">//...</span>
        <span class="kt">dev_t</span>                   <span class="n">s_dev</span><span class="p">;</span>              <span class="cm">/* identifier */</span>
        <span class="kt">unsigned</span> <span class="kt">char</span>           <span class="n">s_blocksize_bits</span><span class="p">;</span>   <span class="cm">/* block size in bits */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>           <span class="n">s_blocksize</span><span class="p">;</span>        <span class="cm">/* block size in bytes */</span>
        <span class="kt">unsigned</span> <span class="kt">char</span>           <span class="n">s_dirt</span><span class="p">;</span>             <span class="cm">/* dirty flag */</span>
        <span class="n">loff_t</span>                  <span class="n">s_maxbytes</span><span class="p">;</span>         <span class="cm">/* max file size */</span>
        <span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">s_type</span><span class="p">;</span>            <span class="cm">/* filesystem type */</span>
        <span class="k">struct</span> <span class="n">super_operations</span> <span class="o">*</span><span class="n">s_op</span><span class="p">;</span>              <span class="cm">/* superblock methods */</span>
        <span class="c1">//...</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>           <span class="n">s_flags</span><span class="p">;</span>            <span class="cm">/* mount flags */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>           <span class="n">s_magic</span><span class="p">;</span>            <span class="cm">/* filesystem’s magic number */</span>
        <span class="k">struct</span> <span class="n">dentry</span>           <span class="o">*</span><span class="n">s_root</span><span class="p">;</span>            <span class="cm">/* directory mount point */</span>
        <span class="c1">//...</span>
        <span class="kt">char</span>                    <span class="n">s_id</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>           <span class="cm">/* informational name */</span>
        <span class="kt">void</span>                    <span class="o">*</span><span class="n">s_fs_info</span><span class="p">;</span>         <span class="cm">/* filesystem private info */</span>
<span class="p">};</span>
</pre></div>
</div>
<dl class="docutils">
<dt>The superblock stores global information for an instance of a file system:</dt>
<dd><ul class="first last simple">
<li>the physical device on which it resides</li>
<li>block size</li>
<li>the maximum size of a file</li>
<li>file system type</li>
<li>the operations it supports</li>
<li>magic number (identifies the file system)</li>
<li>the root directory <code class="docutils literal"><span class="pre">dentry</span></code></li>
</ul>
</dd>
</dl>
<p>Additionally, a generic pointer (<code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span></code>) stores the private data of the file system.
The superblock can be viewed as an abstract object to which its own data is added when there is a concrete implementation.</p>
</div>
<div class="section" id="superblock-operations">
<span id="superblocksection"></span><h3>Superblock operations<a class="headerlink" href="#superblock-operations" title="Permalink to this headline">¶</a></h3>
<p>The superblock operations are described by the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_operations</span></code> structure:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">super_operations</span> <span class="p">{</span>
       <span class="c1">//...</span>
       <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_inode</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">);</span>
       <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">alloc_inode</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
       <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy_inode</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>

       <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">put_super</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
       <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">statfs</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstatfs</span> <span class="o">*</span><span class="p">);</span>
       <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">remount_fs</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
       <span class="c1">//...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The fields of the structure are function pointers with the following meanings:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">write_inode</span></code>, <code class="docutils literal"><span class="pre">alloc_inode</span></code>, <code class="docutils literal"><span class="pre">destroy_inode</span></code> write, allocate, respectively release resources associated with an inode and are described in the next lab</li>
<li><code class="docutils literal"><span class="pre">put_super</span></code> is called when the superblock is released at <code class="docutils literal"><span class="pre">umount</span></code>; within this function, any resources (generally memory) from the file system's private data must be released;</li>
<li><code class="docutils literal"><span class="pre">remount_fs</span></code> is called when the kernel detects a remount attempt (mount flag <code class="docutils literal"><span class="pre">MS_REMOUNTM</span></code>); most of the time here must be detected if a switch from read-only to read-write or vice versa is attempted; this can be done simply because both the old flags (in <code class="docutils literal"><span class="pre">sb-&gt;s_flags</span></code>) and the new flags (the <code class="docutils literal"><span class="pre">flags</span></code> argument) can be accessed; <code class="docutils literal"><span class="pre">data</span></code> is a pointer to the data sent by <code class="xref c c-func docutils literal"><span class="pre">mount()</span></code> that represent file system specific options;</li>
<li><code class="docutils literal"><span class="pre">statfs</span></code> is called when a <code class="docutils literal"><span class="pre">statfs</span></code> system call is done (try <code class="docutils literal"><span class="pre">stat</span> <span class="pre">–f</span></code> or <code class="docutils literal"><span class="pre">df</span></code>); this call must fill the fields of the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">kstatfs</span></code> structure, as it is done, for example, in the <code class="xref c c-func docutils literal"><span class="pre">ext4_statfs()</span></code> function.</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="the-fill-super-function">
<span id="fillsupersection"></span><h2>The <code class="xref c c-func docutils literal"><span class="pre">fill_super()</span></code> function<a class="headerlink" href="#the-fill-super-function" title="Permalink to this headline">¶</a></h2>
<p>As specified, the <code class="xref c c-func docutils literal"><span class="pre">fill_super()</span></code> function is called to terminate the superblock initialization. This initialization involves filling the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span></code> structure fields and the initialization of the root directory inode.</p>
<p>An example of implementation is the <code class="xref c c-func docutils literal"><span class="pre">ramfs_fill_super()</span></code> function which is called to initialize the remaining fields in the superblock:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/pagemap.h&gt;</span><span class="cp"></span>

<span class="cp">#define RAMFS_MAGIC     0x858458f6</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">super_operations</span> <span class="n">ramfs_ops</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">statfs</span>         <span class="o">=</span> <span class="n">simple_statfs</span><span class="p">,</span>
        <span class="p">.</span><span class="n">drop_inode</span>     <span class="o">=</span> <span class="n">generic_delete_inode</span><span class="p">,</span>
        <span class="p">.</span><span class="n">show_options</span>   <span class="o">=</span> <span class="n">ramfs_show_options</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ramfs_fill_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">silent</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">ramfs_fs_info</span> <span class="o">*</span><span class="n">fsi</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

        <span class="n">save_mount_options</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

        <span class="n">fsi</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ramfs_fs_info</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
        <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span> <span class="o">=</span> <span class="n">fsi</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fsi</span><span class="p">)</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

        <span class="n">err</span> <span class="o">=</span> <span class="n">ramfs_parse_options</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsi</span><span class="o">-&gt;</span><span class="n">mount_opts</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">err</span><span class="p">;</span>

        <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_maxbytes</span>          <span class="o">=</span> <span class="n">MAX_LFS_FILESIZE</span><span class="p">;</span>
        <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span>         <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
        <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span>    <span class="o">=</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
        <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_magic</span>             <span class="o">=</span> <span class="n">RAMFS_MAGIC</span><span class="p">;</span>
        <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span>                <span class="o">=</span> <span class="o">&amp;</span><span class="n">ramfs_ops</span><span class="p">;</span>
        <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_time_gran</span>         <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="n">inode</span> <span class="o">=</span> <span class="n">ramfs_get_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">S_IFDIR</span> <span class="o">|</span> <span class="n">fsi</span><span class="o">-&gt;</span><span class="n">mount_opts</span><span class="p">.</span><span class="n">mode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span> <span class="o">=</span> <span class="n">d_make_root</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">)</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The kernel provides generic function to implement operations with file system structures.
The <code class="xref c c-func docutils literal"><span class="pre">generic_delete_inode()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">simple_statfs()</span></code> functions used in the above code are such functions and can be used to implement the drivers if their functionality is sufficient.</p>
<p>The <code class="xref c c-func docutils literal"><span class="pre">ramfs_fill_super()</span></code> function in the above code fills some fields in the superblock, then reads the root inode and allocates the root dentry.
Reading the root inode is done in the <code class="xref c c-func docutils literal"><span class="pre">ramfs_get_inode()</span></code> function, and consists of allocating a new inode using <code class="xref c c-func docutils literal"><span class="pre">new_inode()</span></code> and initializing it. In order to free the inode, <code class="xref c c-func docutils literal"><span class="pre">iput()</span></code> is used, and <code class="xref c c-func docutils literal"><span class="pre">d_make_root()</span></code> is used to allocate the root dentry.</p>
<p>An example implementation for a disk file system is the <code class="xref c c-func docutils literal"><span class="pre">minix_fill_super()</span></code> function in the minix file system.
The functionality for the disk file system is similar to that of the virtual file system, with the exception of using the buffer cache.
Also, the minix file system keeps private data using the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">minix_sb_info</span></code> structure.
A large part of this function deals with the initialization of these private data.
The private data is allocated using the <code class="xref c c-func docutils literal"><span class="pre">kzalloc()</span></code> function and stored in the <code class="docutils literal"><span class="pre">s_fs_info</span></code> field of the superblock structure.</p>
<p>VFS functions typically get as arguments the superblock, an inode and/or a dentry that contain a pointer to the superblock so that these private data can be easily accessed.</p>
</div>
<div class="section" id="buffer-cache">
<span id="buffercachesection"></span><h2>Buffer cache<a class="headerlink" href="#buffer-cache" title="Permalink to this headline">¶</a></h2>
<p>Buffer cache is a kernel subsystem that handles caching (both read and write) blocks from block devices.
The base entity used by buffer cache is the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">buffer_head</span></code> structure.
The most important fields in this structure are:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">b_data</span></code>, pointer to a memory area where the data was read from or where the data must be written to</li>
<li><code class="docutils literal"><span class="pre">b_size</span></code>, buffer size</li>
<li><code class="docutils literal"><span class="pre">b_bdev</span></code>, the block device</li>
<li><code class="docutils literal"><span class="pre">b_blocknr</span></code>, the number of block on the device that has been loaded or needs to be saved on the disk</li>
<li><code class="docutils literal"><span class="pre">b_state</span></code>, the status of the buffer</li>
</ul>
</div></blockquote>
<p>There are some important functions that work with these structures:</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-func docutils literal"><span class="pre">__bread()</span></code>: reads a block with the given number and given size in a <code class="docutils literal"><span class="pre">buffer_head</span></code> structure; in case of success returns a pointer to the <code class="docutils literal"><span class="pre">buffer_head</span></code> structure, otherwise it returns <code class="docutils literal"><span class="pre">NULL</span></code>;</li>
<li><code class="xref c c-func docutils literal"><span class="pre">sb_bread()</span></code>: does the same thing as the previous function, but the size of the read block is taken from the superblock, as well as the device from which the read is done;</li>
<li><code class="xref c c-func docutils literal"><span class="pre">mark_buffer_dirty()</span></code>: marks the buffer as dirty (sets the <code class="docutils literal"><span class="pre">BH_Dirty</span></code> bit); the buffer will be written to the disk at a later time (from time to time the <code class="docutils literal"><span class="pre">bdflush</span></code> kernel thread wakes up and writes the buffers to disk);</li>
<li><code class="xref c c-func docutils literal"><span class="pre">brelse()</span></code>: frees up the memory used by the buffer, after it has previously written the buffer on disk if needed;</li>
<li><code class="xref c c-func docutils literal"><span class="pre">map_bh()</span></code>: associates the buffer-head with the corresponding sector.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="functions-and-useful-macros">
<h2>Functions and useful macros<a class="headerlink" href="#functions-and-useful-macros" title="Permalink to this headline">¶</a></h2>
<p>The super block typically contains a map of occupied blocks (by inodes, dentries, data) in the form of a bitmap (vector of bits). To work with such maps, it is recommend to use the following features:</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-func docutils literal"><span class="pre">find_first_zero_bit()</span></code>, to find the first zero bit in a memory area. The size parameter means the number of bits in the search area;</li>
<li><code class="xref c c-func docutils literal"><span class="pre">test_and_set_bit()</span></code>, to set a bit and get the old value;</li>
<li><code class="xref c c-func docutils literal"><span class="pre">test_and_clear_bit()</span></code>, to delete a bit and get the old value;</li>
<li><code class="xref c c-func docutils literal"><span class="pre">test_and_change_bit()</span></code>, to invert the value of a bit and get the old value.</li>
</ul>
</div></blockquote>
<p>The following macrodefinitions can be used to verify the type of an inode:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">S_ISDIR</span></code> (<code class="docutils literal"><span class="pre">inode-&gt;i_mode</span></code>) to check if the inode is a directory;</li>
<li><code class="docutils literal"><span class="pre">S_ISREG</span></code> (<code class="docutils literal"><span class="pre">inode-&gt;i_mode</span></code>) to check if the inode is a regular file (not a link or device file).</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="further-reading">
<h2>Further reading<a class="headerlink" href="#further-reading" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li>Robert Love -- Linux Kernel Development, Second Edition -- Chapter
12. The Virtual Filesystem</li>
<li>Understanding the Linux Kernel, 3rd edition - Chapter 12. The Virtual
Filesystem</li>
<li><a class="reference external" href="http://www.coda.cs.cmu.edu/doc/talks/linuxvfs/">Linux Virtual File System (presentation)</a></li>
<li><a class="reference external" href="http://www.cyberciti.biz/tips/understanding-unixlinux-file-system-part-i.html">Understanding Unix/Linux Filesystem</a></li>
<li><a class="reference external" href="http://lwn.net/Articles/57369/">Creating Linux virtual filesystems</a></li>
<li><a class="reference external" href="http://www.tldp.org/LDP/tlk/fs/filesystem.html">The Linux Documentation Project - VFS</a></li>
<li><a class="reference external" href="http://www.linux.it/~rubini/docs/vfs/vfs.html">The &quot;Virtual File System&quot; in Linux</a></li>
<li><a class="reference external" href="http://inglorion.net/documents/tutorials/tutorfs/">A Linux Filesystem Tutorial</a></li>
<li><a class="reference external" href="http://www.win.tue.nl/~aeb/linux/lk/lk-8.html">The Linux Virtual File System</a></li>
<li><a class="reference external" href="http://lxr.free-electrons.com/source/Documentation/filesystems/vfs.txt">Documentation/filesystems/vfs.txt</a></li>
<li><a class="reference external" href="http://lxr.free-electrons.com/source/fs/">File systems sources</a></li>
</ol>
</div>
<div class="section" id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p>To solve exercises, you need to perform these steps:</p>
<blockquote>
<div><ul class="simple">
<li>prepare skeletons from templates</li>
<li>build modules</li>
<li>copy modules to the VM</li>
<li>start the VM and test the module in the VM.</li>
</ul>
</div></blockquote>
<p>The current lab name is filesystems. See the exercises for the task name.</p>
<p>The skeleton code is generated from full source examples located in
<code class="file docutils literal"><span class="pre">tools/labs/templates</span></code>. To solve the tasks, start by generating
the skeleton code for a complete lab:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make clean
tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt; make skels
</pre></div>
</div>
<p>You can also generate the skeleton for a single task, using</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt;/&lt;task name&gt; make skels
</pre></div>
</div>
<p>Once the skeleton drivers are generated, build the source:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make build
</pre></div>
</div>
<p>Then, copy the modules and start the VM:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make copy
tools/labs $ make boot
</pre></div>
</div>
<p>The modules are placed in /home/root/skels/filesystems/&lt;task_name&gt;.</p>
<p>Alternatively, we can copy files via <strong class="command">scp</strong>, in order to avoid restarting the VM.
For additional details about connecting to the VM via the network, please check <a class="reference internal" href="../info/vm.html#vm-interaction-link"><span class="std std-ref">Connecting to the Virtual Machine</span></a>.</p>
<p class="last">Review the <a class="reference internal" href="#exercises">Exercises</a> section for more detailed information.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>Before starting the exercises or generating the skeletons, please run <strong>git pull</strong> inside the Linux repo,
to make sure you have the latest version of the exercises.</p>
<p>If you have local changes, the pull command will fail. Check for local changes using <code class="docutils literal"><span class="pre">git</span> <span class="pre">status</span></code>.
If you want to keep them, run <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span></code> before <code class="docutils literal"><span class="pre">pull</span></code> and <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span> <span class="pre">pop</span></code> after.
To discard the changes, run <code class="docutils literal"><span class="pre">git</span> <span class="pre">reset</span> <span class="pre">--hard</span> <span class="pre">master</span></code>.</p>
<p class="last">If you already generated the skeleton before <code class="docutils literal"><span class="pre">git</span> <span class="pre">pull</span></code> you will need to generate it again.</p>
</div>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">In order to have a better understanding of what we do well and we can do
better, what factors affect your implication in teaching, extracurricular
but also professional activities, we ask you to complete <a class="reference external" href="https://forms.office.com/r/SqBF2kfzk5">this survey</a>. The survey is a short one,
having answers with check marks, with an estimated completion time of
3-5 minutes. Obviously, we will send you the analysis of the survey and
use it to improve the teaching activities.</p>
</div>
<div class="section" id="myfs">
<h3>myfs<a class="headerlink" href="#myfs" title="Permalink to this headline">¶</a></h3>
<p>To begin, we plan to get familiar with the interface exposed by the Linux kernel and the Virtual File System (VFS) component. That is why, for the beginning, we will work with a simple, virtual file system (i.e. without physical disk support). The file system is called <code class="docutils literal"><span class="pre">myfs</span></code>.</p>
<p>For this we will access the <code class="docutils literal"><span class="pre">myfs/</span></code> subdirectory in the laboratory skeleton. We will implement the superblock operations within this lab, and the next lab will continue with the inode operations.</p>
<div class="section" id="register-and-unregister-the-myfs-file-system">
<h4>1. Register and unregister the myfs file system<a class="headerlink" href="#register-and-unregister-the-myfs-file-system" title="Permalink to this headline">¶</a></h4>
<p>The first step in working with the file system is to register and unregister it. We want to do this for the file system described in <code class="docutils literal"><span class="pre">myfs.c</span></code>. Check the file contents and follow the directions marked with <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">1</span></code>.</p>
<p>The steps you need to take are described in the section <a class="reference internal" href="#registerunregistersection"><span class="std std-ref">Register and unregister filesystems</span></a>. Use the <code class="docutils literal"><span class="pre">&quot;myfs&quot;</span></code> string for the file system name.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Within the file system structure, use the <code class="docutils literal"><span class="pre">myfs_mount</span></code> function present in the code skeleton to fill the superblock (done when mounting). In <code class="docutils literal"><span class="pre">myfs_mount</span></code> call the function specific to a file system without disk support. As an argument for the specific mount function, use the function of type <code class="docutils literal"><span class="pre">fill_super</span></code> defined in the code skeleton. You can review the <a class="reference internal" href="#functionsmountkillsbsection"><span class="std std-ref">Functions mount, kill_sb</span></a> section.</p>
<p class="last">To destroy the superblock (done at unmounting) use <code class="docutils literal"><span class="pre">kill_litter_super</span></code>, also a function specific to a file system without disk support. The function is already implemented, you need to fill it in the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file_system_type</span></code> structure.</p>
</div>
<p>After completing the sections marked with <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">1</span></code> , compile the module, copy it to the QEMU virtual machine, and start the virtual machine. Load the kernel module and then check the presence of the <code class="docutils literal"><span class="pre">myfs</span></code> file system within the <code class="docutils literal"><span class="pre">/proc/filesystems</span></code> file.</p>
<p>At the moment, the file system is only registered, it does not expose operations to use it. If we try to mount it, the operation will fail. To try mounting, we create mount point <code class="docutils literal"><span class="pre">/mnt/myfs/</span></code>.</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> mkdir -p /mnt/myfs
</pre></div>
</div>
<p>and then we use the <code class="docutils literal"><span class="pre">mount</span></code> command:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> mount -t myfs none /mnt/myfs
</pre></div>
</div>
<p>The error message we get shows that we have not implemented the operations that work on the superblock. We will have to implement the operations on the superblock and initialize the root inode. We will do this further.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <code class="docutils literal"><span class="pre">none</span></code> argument sent to the <code class="docutils literal"><span class="pre">mount</span></code> command indicates that we do not have a device from which to mount, the file system being a virtual one. Similarly, this is how the <code class="docutils literal"><span class="pre">procfs</span></code> or <code class="docutils literal"><span class="pre">sysfs</span></code> filesystems are mounted on Linux systems.</p>
</div>
</div>
<div class="section" id="completing-myfs-superblock">
<h4>2. Completing myfs superblock<a class="headerlink" href="#completing-myfs-superblock" title="Permalink to this headline">¶</a></h4>
<p>To be able to mount the file system, we need to fill its superblock's fields, that is, a generic VFS structure of type <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span></code>.
We will fill out the structure within the <code class="xref c c-func docutils literal"><span class="pre">myfs_fill_super()</span></code> function; the superblock is represented by the variable <code class="docutils literal"><span class="pre">sb</span></code> passed as an argument to the function.
Follow the hints marked with <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">2</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>To fill the <code class="docutils literal"><span class="pre">myfs_fill_super</span></code> function, you can start from the example in the section <a class="reference internal" href="#fillsupersection"><span class="std std-ref">The fill_super() function</span></a>.</p>
<p class="last">For the superblock structure fields, use the macros defined within the code skeleton wherever possible.</p>
</div>
<p>The <code class="docutils literal"><span class="pre">s_op</span></code> field in the superblock structure must be initialized to the superblock operations structures (type <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_operations</span></code>). You need to define such a structure.</p>
<p>For information on defining the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_operations</span></code> structure and filling the superblock, see the section <a class="reference internal" href="#superblocksection"><span class="std std-ref">Superblock operations</span></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Initialize the <code class="docutils literal"><span class="pre">drop_inode</span></code> and <code class="docutils literal"><span class="pre">statfs</span></code> fields of <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_operations</span></code> structure.</p>
</div>
<p>Although the superblock will be properly initialized at this time, the mount operation will continue to fail.
In order for the operation to be successfully completed, the root inode will have to be initialized, which we will do for the next exercise.</p>
</div>
<div class="section" id="initialize-myfs-root-inode">
<h4>3. Initialize myfs root inode<a class="headerlink" href="#initialize-myfs-root-inode" title="Permalink to this headline">¶</a></h4>
<p>The root inode is the inode of the file system root directory (i.e. <code class="docutils literal"><span class="pre">/</span></code>).
Initialization is done when the file system is mounted.
The <code class="docutils literal"><span class="pre">myfs_fill_super</span></code> function, called at mount, is the one that calls the <code class="docutils literal"><span class="pre">myfs_get_inode</span></code> function that creates and initializes an inode.
Typically, this function is used to create and initialize all inodes; In this exercise, however, we will only create the root inode.</p>
<p>The <code class="xref c c-type docutils literal"><span class="pre">inode</span></code> is allocated inside the <code class="docutils literal"><span class="pre">myfs_get_inode</span></code> function (local variable <code class="docutils literal"><span class="pre">inode</span></code>, allocated using the <code class="xref c c-func docutils literal"><span class="pre">new_inode()</span></code> function call).</p>
<p>To successfully complete mounting the file system, you will need to fill the <code class="docutils literal"><span class="pre">myfs_get_inode</span></code> function. Follow directions marked with <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">3</span></code>. A starting point is the <a class="reference external" href="https://elixir.bootlin.com/linux/latest/source/fs/ramfs/inode.c#L63">ramfs_get_inode</a> function.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>To initialize <code class="docutils literal"><span class="pre">uid</span></code>, <code class="docutils literal"><span class="pre">gid</span></code> and <code class="docutils literal"><span class="pre">mode</span></code> , you can use the <code class="xref c c-func docutils literal"><span class="pre">inode_init_owner()</span></code> function as it is used in <code class="xref c c-func docutils literal"><span class="pre">ramfs_get_inode()</span></code>.
When you call <code class="xref c c-func docutils literal"><span class="pre">inode_init_owner()</span></code>, use <code class="docutils literal"><span class="pre">NULL</span></code> as the second parameter because there is no parent directory for the created inode.</p>
<p>Initialize the <code class="docutils literal"><span class="pre">i_atime</span></code>, <code class="docutils literal"><span class="pre">i_ctime</span></code>, and <code class="docutils literal"><span class="pre">i_mtime</span></code> of the VFS inode to the value returned by the <code class="xref c c-func docutils literal"><span class="pre">current_time()</span></code> function.</p>
<p>You will need to initialize the operations for the inode of type directory. To do this, follow the steps:</p>
<blockquote class="last">
<div><ol class="arabic simple">
<li>Check if this is a directory type inode using the <code class="docutils literal"><span class="pre">S_ISDIR</span></code> macro.</li>
<li>For the <code class="docutils literal"><span class="pre">i_op</span></code> and <code class="docutils literal"><span class="pre">i_fop</span></code> fields, use kernel functions that are already implemented:<ul>
<li>for <code class="docutils literal"><span class="pre">i_op</span></code>: <code class="xref c c-type docutils literal"><span class="pre">simple_dir_inode_operations</span></code>.</li>
<li>for <code class="docutils literal"><span class="pre">i_fop</span></code>: <code class="xref c c-type docutils literal"><span class="pre">simple_dir_operations</span></code></li>
</ul>
</li>
<li>Increase the number of links for the directory using the <code class="xref c c-func docutils literal"><span class="pre">inc_nlink()</span></code> function.</li>
</ol>
</div></blockquote>
</div>
</div>
<div class="section" id="test-myfs-mount-and-unmount">
<h4>4. Test myfs mount and unmount<a class="headerlink" href="#test-myfs-mount-and-unmount" title="Permalink to this headline">¶</a></h4>
<p>Now we can mount the filesystem.
Follow the steps above to compile the kernel module, copy to the virtual machine, and start the virtual machine, then insert the kernel module, create the mount point <code class="docutils literal"><span class="pre">/mnt/myfs/</span></code>, and mount the file system.
We verify that the file system was mounted by inspecting the <code class="docutils literal"><span class="pre">/proc/mounts</span></code> file.</p>
<p>What inode number does the <code class="docutils literal"><span class="pre">/mnt/myfs</span></code> directory have? Why?</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>To display the inode number of a directory, use the command:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">ls -di /path/to/directory</span>
</pre></div>
</div>
<p class="last">where <code class="docutils literal"><span class="pre">/path/to/directory/</span></code> is the path to the directory whose inode number we want to display.</p>
</div>
<p>We check myfs file system statistics using the following command:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">stat -f /mnt/myfs</span>
</pre></div>
</div>
<p>We want to see what the mount point <code class="docutils literal"><span class="pre">/mnt/myfs</span></code> contains and if we can create files.
For this we run the commands:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> ls -la /mnt/myfs
<span class="gp">#</span> touch /mnt/myfs/a.txt
</pre></div>
</div>
<p>We can see that we can not create the <code class="docutils literal"><span class="pre">a.txt</span></code> file on the file system.
This is because we have not implemented the operations to work with inodes in the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_operations</span></code> structure.
We will implement these operations within the next lab.</p>
<p>Unmount the file system using the command</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">umount /mnt/myfs</span>
</pre></div>
</div>
<p>Unload the kernel module corresponding to the file system as well.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>To test the entire functionality, you can use the <code class="docutils literal"><span class="pre">test-myfs.sh</span></code> script:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">./test-myfs.sh</span>
</pre></div>
</div>
<p>The script is copied to the virtual machine using <code class="docutils literal"><span class="pre">make</span> <span class="pre">copy</span></code> only if it is executable:</p>
<div class="last highlight-console"><div class="highlight"><pre><span></span><span class="gp">student@workstation:~/linux/tools/labs$</span> chmod +x skels/filesystems/myfs/test-myfs.sh
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The statistics displayed for the file system are minimal because the information is provided by the simple_statfs function.</p>
</div>
</div>
</div>
<div class="section" id="minfs">
<h3>minfs<a class="headerlink" href="#minfs" title="Permalink to this headline">¶</a></h3>
<p>Next, we will implement the basics of a very simple file system, called <code class="docutils literal"><span class="pre">minfs</span></code>, with disk support.
We will use a disk in the virtual machine that we will format and mount with the <code class="docutils literal"><span class="pre">minfs</span></code> filesystem.</p>
<p>For this we will access the <code class="docutils literal"><span class="pre">minfs/kernel</span></code> directory from the laboratory skeleton and work with the code in <code class="docutils literal"><span class="pre">minfs.c</span></code>.
Just like <code class="docutils literal"><span class="pre">myfs</span></code> we will not implement the operations for working with inodes. We will just limit to working with the superblock and, therefore, mounting.
The rest of the operations will be implemented in the next lab.</p>
<p>Follow the diagram below to clarify the role of structures within the <code class="docutils literal"><span class="pre">minfs</span></code> file system.</p>
<img alt="../_images/minfs1.png" src="../_images/minfs1.png" />
<div class="section" id="registering-and-unregistering-the-minfs-file-system">
<h4>1. Registering and unregistering the minfs file system<a class="headerlink" href="#registering-and-unregistering-the-minfs-file-system" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Before solving the exercise, we need to add a disk to the virtual machine. To do this, generate a file that we will use as the disk image using the following command:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">dd if=/dev/zero of=mydisk.img bs=1M count=100</span>
</pre></div>
</div>
<p class="last">and add the <code class="docutils literal"><span class="pre">-drive</span> <span class="pre">file=mydisk.img,if=virtio,format=raw</span></code> argument to the <code class="docutils literal"><span class="pre">qemu</span></code> command in <code class="docutils literal"><span class="pre">qemu/Makefile</span></code> (in the <code class="docutils literal"><span class="pre">QEMU_OPTS</span></code> variable).
The new argument for the <code class="docutils literal"><span class="pre">qemu</span></code> command must be added after the one for the existing disk (<code class="docutils literal"><span class="pre">YOCTO_IMAGE</span></code>).</p>
</div>
<p>To register and unregister the file system, you will need to fill the <code class="docutils literal"><span class="pre">minfs_fs_type</span></code> and <code class="docutils literal"><span class="pre">minfs_mount</span></code> functions in <code class="docutils literal"><span class="pre">minfs.c</span></code>. Follow the directions marked with <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">1</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>In the file system structure, for mount, use the <code class="docutils literal"><span class="pre">minfs_mount</span></code> function from in the code skeleton.
In this function, call the function to mount a file system with disk support (See the <a class="reference internal" href="#functionsmountkillsbsection"><span class="std std-ref">Functions mount, kill_sb</span></a> section. Use <code class="xref c c-func docutils literal"><span class="pre">mount_bdev()</span></code>).
Choose the most suitable function for destroying the superblock (done at unmount); keep in mind that it is a file system with disk support. Use the <code class="xref c c-func docutils literal"><span class="pre">kill_block_super()</span></code> function.</p>
<p>Initialize the <code class="docutils literal"><span class="pre">fs_flags</span></code> field of the <code class="xref c c-type docutils literal"><span class="pre">minfs_fs_type</span></code> structure with the appropriate value for a file system with disk support. See the section <a class="reference internal" href="#registerunregistersection"><span class="std std-ref">Register and unregister filesystems</span></a>.</p>
<p class="last">The function for filling the superblock is <code class="docutils literal"><span class="pre">minfs_fill_super</span></code>.</p>
</div>
<p>After completing the sections marked with <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">1</span></code>, compile the module, copy it into the QEMU virtual machine, and start the virtual machine.
Load the kernel module and then check the presence of the <code class="docutils literal"><span class="pre">minfs</span></code> file system within the <code class="docutils literal"><span class="pre">/proc/filesystems</span></code> file.</p>
<p>To test the mounting of the <code class="docutils literal"><span class="pre">minfs</span></code> file system we will need to format the disk with its structure. Formatting requires the <code class="docutils literal"><span class="pre">mkfs.minfs</span></code> formatting tool from the <code class="docutils literal"><span class="pre">minfs/user</span></code> directory. The utility is automatically compiled when running <code class="docutils literal"><span class="pre">make</span> <span class="pre">build</span></code> and copied to the virtual machine at <code class="docutils literal"><span class="pre">make</span> <span class="pre">copy</span></code>.</p>
<p>After compiling, copying, and starting the virtual machine, format the <code class="docutils literal"><span class="pre">/dev/vdd</span></code> using the formatting utility:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> ./mkfs.minfs /dev/vdd
</pre></div>
</div>
<p>Load the kernel module:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> insmod minfs.ko
</pre></div>
</div>
<p>Create mount point <code class="docutils literal"><span class="pre">/mnt/minfs/</span></code>:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> mkdir -p /mnt/minfs/
</pre></div>
</div>
<p>and mount the filesystem</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> mount -t minfs /dev/vdd /mnt/minfs/
</pre></div>
</div>
<p>The operation fails because the root inode is not initialized.</p>
</div>
<div class="section" id="completing-minfs-superblock">
<h4>2. Completing minfs superblock<a class="headerlink" href="#completing-minfs-superblock" title="Permalink to this headline">¶</a></h4>
<p>To be able to mount the file system, you will need to fill the superblock (i.e a structure with type <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span></code>) within the <code class="docutils literal"><span class="pre">minfs_fill_super</span></code> function; it is the <code class="docutils literal"><span class="pre">s</span></code> argument of the function.
The structure of operations on the superblock is already defined: <code class="docutils literal"><span class="pre">minfs_ops</span></code>.
Follow the directions marked with <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">2</span></code>. You can also follow the implementation of the <a class="reference external" href="https://elixir.bootlin.com/linux/latest/source/fs/minix/inode.c#L153">minix_fill_super</a> function.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Some structures are found in the header file <code class="docutils literal"><span class="pre">minfs.h</span></code>.</p>
<p>For information on working with buffers, go to the <a class="reference internal" href="#buffercachesection"><span class="std std-ref">Buffer cache</span></a> section.</p>
<p>Read the first block on the disk (block with index 0).
To read the block, use the <code class="xref c c-func docutils literal"><span class="pre">sb_bread()</span></code> function.
Cast the read data (the <code class="docutils literal"><span class="pre">b_data</span></code> field in the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">buffer_head</span></code> structure) to the structure storing the <code class="docutils literal"><span class="pre">minfs</span></code> superblock information on the disk: <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">minfs_super_block</span></code>, defined in the source code file.</p>
<p class="last">Structure <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">minfs_super_block</span></code> holds file system-specific information that is not found in the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span></code> generic structure (in this case only version).
Those additional information (found in <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">minfs_super_block</span></code> (on disk) but not in <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span></code> (VFS)) will be stored in the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">minfs_sb_info</span></code> structure.</p>
</div>
<p>To check the functionality, we need a function for reading the root inode.
For the time being, use the <code class="docutils literal"><span class="pre">myfs_get_inode</span></code> function from <code class="docutils literal"><span class="pre">myfs</span></code> file system exercises.
Copy the function into the source code and call it the same as you did for myfs.
The third argument when calling the <code class="docutils literal"><span class="pre">myfs_get_inode</span></code> function is the inode creation permissions, similar to the virtual file system exercise (myfs).</p>
<p>Validate the implementation by executing the commands from the previous exercise.</p>
</div>
<div class="section" id="creating-and-destroying-minfs-inodes">
<h4>3. Creating and destroying minfs inodes<a class="headerlink" href="#creating-and-destroying-minfs-inodes" title="Permalink to this headline">¶</a></h4>
<p>For mounting, we need to initialize the root inode, and to get the root inode, we need to implement the functions to work with inodes.
That is, you need to implement the <code class="docutils literal"><span class="pre">minfs_alloc_inode</span></code> and <code class="docutils literal"><span class="pre">minfs_destroy_inode</span></code> functions.
Follow the directions marked with <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">3</span></code>. You can use the <code class="xref c c-func docutils literal"><span class="pre">minix_alloc_inode()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">minix_destroy_inode()</span></code> functions as a model.</p>
<p>For the implementation, look at the macros and structures in the <code class="docutils literal"><span class="pre">minfs.h</span></code> header file.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>For memory allocation/deallocation in <code class="docutils literal"><span class="pre">minfs_alloc_inode</span></code> and <code class="docutils literal"><span class="pre">minfs_destroy_inode</span></code>, we recommend using <code class="xref c c-func docutils literal"><span class="pre">kzalloc()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">kfree()</span></code>.</p>
<p>In <code class="docutils literal"><span class="pre">minfs_alloc_inode</span></code> allocate structures with type <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">minfs_inode_info</span></code>, but only return structures with type <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">inode</span></code>, i.e. return those given by the <code class="docutils literal"><span class="pre">vfs_inode</span></code> field.</p>
<p>In the <code class="docutils literal"><span class="pre">minfs_alloc_inode</span></code> function, call <code class="xref c c-func docutils literal"><span class="pre">inode_init_once()</span></code> to initialize the inode.</p>
<p class="last">In the <code class="docutils literal"><span class="pre">destroy_inode</span></code> function, you can access the structure with type <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">minfs_inode_info</span></code> using the <code class="docutils literal"><span class="pre">container_of</span></code> macro.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In this exercise, you have implemented the <code class="docutils literal"><span class="pre">minfs_alloc_inode</span></code> and <code class="docutils literal"><span class="pre">minfs_destroy_inode</span></code> functions, but they are not yet called. The correctness of the implementation will be checked at the end of the next exercise.</p>
</div>
</div>
<div class="section" id="initialize-minfs-root-inode">
<h4>4. Initialize minfs root inode<a class="headerlink" href="#initialize-minfs-root-inode" title="Permalink to this headline">¶</a></h4>
<p>Initializing the root inode is required in order to mount the file system.
For this, you will need to complete the <code class="docutils literal"><span class="pre">minfs_ops</span></code> structure with the <code class="docutils literal"><span class="pre">minfs_alloc_inode</span></code> and <code class="docutils literal"><span class="pre">minfs_destroy_inode</span></code> functions and fill the <code class="docutils literal"><span class="pre">minfs_iget</span></code> function.</p>
<p>The <code class="docutils literal"><span class="pre">minfs_iget</span></code> function is the function called to allocate a VFS inode (i.e. <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">inode</span></code>) and fill it with minfs inode-specific information from the disk (i.e. <code class="docutils literal"><span class="pre">struct</span> <span class="pre">minfs_inode</span></code>).</p>
<p>Follow the directions marked with <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">4</span></code>.
Fill out the <code class="docutils literal"><span class="pre">alloc_inode</span></code> and <code class="docutils literal"><span class="pre">destroy_inode</span></code> fields of <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_operations</span></code> structure with the functions implemented in the previous step.</p>
<p>The information about the root inode is found in the second block on the disk (the inode with index 1).
Make <code class="docutils literal"><span class="pre">minfs_iget</span></code> read the root minfs inode from the disk (<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">minfs_inode</span></code>) and fill in the VFS inode (<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">inode</span></code>).</p>
<p>In the <code class="docutils literal"><span class="pre">minfs_fill_super</span></code> function, replace the <code class="docutils literal"><span class="pre">myfs_get_inode</span></code> call with the <code class="docutils literal"><span class="pre">minfs_iget</span></code> function call.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>To implement the <code class="docutils literal"><span class="pre">minfs_iget</span></code> function, follow the implementation of <a class="reference external" href="https://elixir.bootlin.com/linux/v4.15/source/fs/minix/inode.c#L460">V1_minix_iget</a>.
To read a block, use the <code class="xref c c-func docutils literal"><span class="pre">sb_bread()</span></code> function.
Cast the read data (the <code class="docutils literal"><span class="pre">b_data</span></code> field of the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">buffer_head</span></code> structure) to the minfs inode from the disk (<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">minfs_inode</span></code>).</p>
<p>The <code class="docutils literal"><span class="pre">i_uid</span></code>, <code class="docutils literal"><span class="pre">i_gid</span></code>, <code class="docutils literal"><span class="pre">i_mode</span></code>, <code class="docutils literal"><span class="pre">i_size</span></code> must be filled in the VFS inode with the values in the minfs inode structure read from disk.
To initialize the <code class="docutils literal"><span class="pre">i_uid</span></code> and <code class="docutils literal"><span class="pre">i_gid</span> <span class="pre">fields</span></code>, use the functions <code class="xref c c-func docutils literal"><span class="pre">i_uid_write()</span></code> , and <code class="xref c c-func docutils literal"><span class="pre">i_gid_write()</span></code>.</p>
<p>Initialize the <code class="docutils literal"><span class="pre">i_atime</span></code> , <code class="docutils literal"><span class="pre">i_ctime</span></code>, and <code class="docutils literal"><span class="pre">i_mtime</span></code> fields of the VFS inode to the value returned by the <code class="xref c c-func docutils literal"><span class="pre">current_time()</span></code> function.</p>
<p>You will need to initialize the operations for the inode with type directory. To do this, follow the steps:</p>
<blockquote class="last">
<div><ol class="arabic simple">
<li>Check if this is a directory type inode using the <code class="docutils literal"><span class="pre">S_ISDIR</span></code> macro.</li>
<li>For the <code class="docutils literal"><span class="pre">i_op</span></code> and <code class="docutils literal"><span class="pre">i_fop</span></code> fields, use kernel functions already implemented:<ul>
<li>for <code class="docutils literal"><span class="pre">i_op</span></code>: <code class="xref c c-func docutils literal"><span class="pre">simple_dir_inode_operations()</span></code> .</li>
<li>for <code class="docutils literal"><span class="pre">i_fop</span></code>: <code class="xref c c-func docutils literal"><span class="pre">simple_dir_operations()</span></code></li>
</ul>
</li>
<li>Increment the number of links for the directory using the <code class="xref c c-func docutils literal"><span class="pre">inc_nlink()</span></code> function.</li>
</ol>
</div></blockquote>
</div>
</div>
<div class="section" id="testing-of-minfs-mount-and-unmount">
<h4>5. Testing of minfs mount and unmount<a class="headerlink" href="#testing-of-minfs-mount-and-unmount" title="Permalink to this headline">¶</a></h4>
<p>Now we can mount the filesystem.
Follow the steps above to compile the kernel module, copy to the virtual machine, start the virtual machine, and then insert the kernel module, create mount point <code class="docutils literal"><span class="pre">/mnt/minfs/</span></code> and mount the file system.
We verify that the file system was mounted by investigating the <code class="docutils literal"><span class="pre">/proc/mounts</span></code> file.</p>
<p>We check that everything is fine by listing the mount point contents <code class="docutils literal"><span class="pre">/mnt/minfs/</span></code>:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> ls /mnt/minfs/
</pre></div>
</div>
<p>After mount and verification, unmount the file system and unload the module from the kernel.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Alternatively, to test the entire functionality, you can use the <code class="docutils literal"><span class="pre">test-minfs.sh</span></code> script:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> ./test-minfs.sh
</pre></div>
</div>
<p>The script is copied to the virtual machine when running the <code class="docutils literal"><span class="pre">make</span> <span class="pre">copy</span></code> command only if is executable.</p>
<div class="last highlight-console"><div class="highlight"><pre><span></span><span class="gp">student@workstation:~/linux/tools/labs$</span> chmod +x skels/filesystems/minfs/user/test-minfs.sh
</pre></div>
</div>
</div>
</div>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="lab7-block-device-drivers.html" class="btn btn-neutral float-left" title="SO2 Lab 07 - Block Device Drivers" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="lab9-filesystems-part2.html" class="btn btn-neutral float-right" title="SO2 Lab 09 - File system drivers (Part 2)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright The kernel development community.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>