<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SO2 Lab 07 - Block Device Drivers &mdash; The Linux Kernel  documentation</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/asciinema-player.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
      <script>
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/asciinema-player.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="SO2 Lab 08 - File system drivers (Part 1)" href="lab8-filesystems-part1.html" />
    <link rel="prev" title="SO2 Lab 06 - Memory Mapping" href="lab6-memory-mapping.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            The Linux Kernel
          </a>
              <div class="version">
                5.10.14
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Operating Systems 2</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="lec1-intro.html">SO2 Lecture 01 - Course overview and Linux kernel introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec2-syscalls.html">SO2 Lecture 02 - System calls</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec3-processes.html">SO2 Lecture 03 - Processes</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec4-interrupts.html">SO2 Lecture 04 - Interrupts</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec5-smp.html">SO2 Lecture 05 - Symmetric Multi-Processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec6-address-space.html">SO2 Lecture 06 - Address Space</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec7-memory-management.html">SO2 Lecture 07 - Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec8-filesystems.html">SO2 Lecture 08 - Filesystem Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec9-debugging.html">SO2 Lecture 09 - Kernel debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec10-networking.html">SO2 Lecture 10 - Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec11-arch.html">SO2 Lecture 11 - Architecture Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec12-virtualization.html">SO2 Lecture 12 - Virtualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab1-intro.html">SO2 Lab 01 - Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab2-kernel-api.html">SO2 Lab 02 - Kernel API</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab3-device-drivers.html">SO2 Lab 03 - Character device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab4-interrupts.html">SO2 Lab 04 - I/O access and Interrupts</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab5-deferred-work.html">SO2 Lab 05 - Deferred work</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab6-memory-mapping.html">SO2 Lab 06 - Memory Mapping</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">SO2 Lab 07 - Block Device Drivers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#lab-objectives">Lab objectives</a></li>
<li class="toctree-l3"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#register-a-block-i-o-device">Register a block I/O device</a></li>
<li class="toctree-l3"><a class="reference internal" href="#register-a-disk">Register a disk</a></li>
<li class="toctree-l3"><a class="reference internal" href="#struct-gendisk-structure"><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span></code> structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#struct-block-device-operations-structure"><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device_operations</span></code> structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#request-queues-multi-queue-block-layer">Request Queues - Multi-Queue Block Layer</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#software-staging-queues">Software staging queues</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hardware-dispatch-queues">Hardware dispatch queues</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tag-sets">Tag sets</a></li>
<li class="toctree-l4"><a class="reference internal" href="#create-and-delete-a-request-queue">Create and delete a request queue</a></li>
<li class="toctree-l4"><a class="reference internal" href="#useful-functions-for-processing-request-queues">Useful functions for processing request queues</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#requests-for-block-devices">Requests for block devices</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#create-a-request">Create a request</a></li>
<li class="toctree-l4"><a class="reference internal" href="#process-a-request">Process a request</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#struct-bio-structure"><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#create-a-struct-bio-structure">Create a <code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#submit-a-struct-bio-structure">Submit a <code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wait-for-the-completion-of-a-struct-bio-structure">Wait for the completion of a <code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#initialize-a-struct-bio-structure">Initialize a <code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#how-to-use-the-content-of-a-struct-bio-structure">How to use the content of a <code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#free-a-struct-bio-structure">Free a <code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#set-up-a-request-queue-at-struct-bio-level">Set up a request queue at <code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> level</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#further-reading">Further reading</a></li>
<li class="toctree-l3"><a class="reference internal" href="#exercises">Exercises</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#intro">0. Intro</a></li>
<li class="toctree-l4"><a class="reference internal" href="#block-device">1. Block device</a></li>
<li class="toctree-l4"><a class="reference internal" href="#disk-registration">2. Disk registration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ram-disk">3. RAM disk</a></li>
<li class="toctree-l4"><a class="reference internal" href="#read-data-from-the-disk">4. Read data from the disk</a></li>
<li class="toctree-l4"><a class="reference internal" href="#write-data-to-the-disk">5. Write data to the disk</a></li>
<li class="toctree-l4"><a class="reference internal" href="#processing-requests-from-the-request-queue-at-struct-bio-level">6. Processing requests from the request queue at <code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> level</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lab8-filesystems-part1.html">SO2 Lab 08 - File system drivers (Part 1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab9-filesystems-part2.html">SO2 Lab 09 - File system drivers (Part 2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab10-networking.html">SO2 Lab 10 - Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab11-arm-kernel-development.html">SO2 Lab 11 - Kernel Development on ARM</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab12-kernel-profiling.html">SO2 Lab 12 - Kernel Profiling</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign-collaboration.html">Collaboration</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign0-kernel-api.html">Assignment 0 - Kernel API</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign1-kprobe-based-tracer.html">Assignment 1 - Kprobe based tracer</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign2-driver-uart.html">Assignment 2 - Driver UART</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign3-software-raid.html">Assignment 3 - Software RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign4-transport-protocol.html">Assignment 4 - SO2 Transport Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign7-kvm-vmm.html">Assignment 7 - SO2 Virtual Machine Manager with KVM</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Lectures</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../lectures/intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/syscalls.html">System Calls</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/interrupts.html">Interrupts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/smp.html">Symmetric Multi-Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/address-space.html">Address Space</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/memory-management.html">Memory Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/fs.html">Filesystem Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/debugging.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/networking.html">Network Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/arch.html">Architecture Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/virt.html">Virtualization</a></li>
</ul>
<p class="caption"><span class="caption-text">Labs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../labs/infrastructure.html">Infrastructure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_modules.html">Kernel modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_api.html">Kernel API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/device_drivers.html">Character device drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/interrupts.html">I/O access and Interrupts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/deferred_work.html">Deferred work</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/block_device_drivers.html">Block Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/filesystems_part1.html">File system drivers (Part 1)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/filesystems_part2.html">File system drivers (Part 2)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/networking.html">Networking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/arm_kernel_development.html">Kernel Development on ARM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/memory_mapping.html">Memory mapping</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/device_model.html">Linux Device Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_profiling.html">Kernel Profiling</a></li>
</ul>
<p class="caption"><span class="caption-text">Useful info</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../info/vm.html">Virtual Machine Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/extra-vm.html">Customizing the Virtual Machine Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/contributing.html">Contributing to linux-kernel-labs</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Operating Systems 2</a></li>
      <li class="breadcrumb-item active">SO2 Lab 07 - Block Device Drivers</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/so2/lab7-block-device-drivers.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="so2-lab-07-block-device-drivers">
<h1>SO2 Lab 07 - Block Device Drivers<a class="headerlink" href="#so2-lab-07-block-device-drivers" title="Permalink to this headline">¶</a></h1>
<div class="section" id="lab-objectives">
<h2>Lab objectives<a class="headerlink" href="#lab-objectives" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li>acquiring knowledge about the behavior of the I/O subsystem on Linux</li>
<li>hands-on activities in structures and functions of block devices</li>
<li>acquiring basic skills for utilizing the API for block devices, by solving
exercises</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>Block devices are characterized by random access to data organized in fixed-size
blocks. Examples of such devices are hard drives, CD-ROM drives, RAM disks, etc.
The speed of block devices is generally much higher than the speed of character
devices, and their performance is also important. This is why the Linux kernel
handles differently these 2 types of devices (it uses a specialized API).</p>
<p>Working with block devices is therefore more complicated than working with
character devices. Character devices have a single current position, while block
devices must be able to move to any position in the device to provide random
access to data. To simplify work with block devices, the Linux kernel provides
an entire subsystem called the block I/O (or block layer) subsystem.</p>
<p>From the kernel perspective, the smallest logical unit of addressing is the
block. Although the physical device can be addressed at sector level, the kernel
performs all disk operations using blocks. Since the smallest unit of physical
addressing is the sector, the size of the block must be a multiple of the size
of the sector. Additionally, the block size must be a power of 2 and can not
exceed the size of a page. The size of the block may vary depending on the file
system used, the most common values being 512 bytes, 1 kilobytes and 4
kilobytes.</p>
</div>
<div class="section" id="register-a-block-i-o-device">
<h2>Register a block I/O device<a class="headerlink" href="#register-a-block-i-o-device" title="Permalink to this headline">¶</a></h2>
<p>To register a block I/O device, function <code class="xref c c-func docutils literal"><span class="pre">register_blkdev()</span></code> is used.
To deregister a block I/O device, function <code class="xref c c-func docutils literal"><span class="pre">unregister_blkdev()</span></code> is
used.</p>
<p>Starting with version 4.9 of the Linux kernel, the call to
<code class="xref c c-func docutils literal"><span class="pre">register_blkdev()</span></code> is optional. The only operations performed by this
function are the dynamic allocation of a major (if the major argument is 0 when
calling the function) and creating an entry in <code class="file docutils literal"><span class="pre">/proc/devices</span></code>. In
future kernel versions it may be removed; however, most drivers still call it.</p>
<p>Usually, the call to the register function is performed in the module
initialization function, and the call to the deregister function is performed in
the module exit function. A typical scenario is presented below:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp"></span>

<span class="cp">#define MY_BLOCK_MAJOR           240</span>
<span class="cp">#define MY_BLKDEV_NAME          &quot;mybdev&quot;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_block_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

    <span class="n">status</span> <span class="o">=</span> <span class="n">register_blkdev</span><span class="p">(</span><span class="n">MY_BLOCK_MAJOR</span><span class="p">,</span> <span class="n">MY_BLKDEV_NAME</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
             <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;unable to register mybdev block device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
             <span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
     <span class="p">}</span>
     <span class="c1">//...</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">my_block_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
     <span class="c1">//...</span>
     <span class="n">unregister_blkdev</span><span class="p">(</span><span class="n">MY_BLOCK_MAJOR</span><span class="p">,</span> <span class="n">MY_BLKDEV_NAME</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="register-a-disk">
<h2>Register a disk<a class="headerlink" href="#register-a-disk" title="Permalink to this headline">¶</a></h2>
<p>Although the <code class="xref c c-func docutils literal"><span class="pre">register_blkdev()</span></code> function obtains a major, it does not
provide a device (disk) to the system. For creating and using block devices
(disks), a specialized interface defined in <code class="file docutils literal"><span class="pre">linux/genhd.h</span></code> is used.</p>
<p>The useful functions defined in <code class="file docutils literal"><span class="pre">linux/genhd.h</span></code> are to register /allocate
a disk, add it to the system, and de-register /unmount the disk.</p>
<p>The <code class="xref c c-func docutils literal"><span class="pre">alloc_disk()</span></code> function is used to allocate a disk, and the
<code class="xref c c-func docutils literal"><span class="pre">del_gendisk()</span></code> function is used to deallocate it. Adding the disk to the
system is done using the <code class="xref c c-func docutils literal"><span class="pre">add_disk()</span></code> function.</p>
<p>The <code class="xref c c-func docutils literal"><span class="pre">alloc_disk()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">add_disk()</span></code> functions are typically used in
the module initialization function, and the <code class="xref c c-func docutils literal"><span class="pre">del_gendisk()</span></code> function in
the module exit function.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/genhd.h&gt;</span><span class="cp"></span>

<span class="cp">#define MY_BLOCK_MINORS       1</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">my_block_dev</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">gd</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="p">}</span> <span class="n">dev</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_block_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_block_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span> <span class="o">=</span> <span class="n">alloc_disk</span><span class="p">(</span><span class="n">MY_BLOCK_MINORS</span><span class="p">);</span>
    <span class="c1">//...</span>
    <span class="n">add_disk</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_block_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//...</span>
    <span class="n">create_block_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">delete_block_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_block_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="p">)</span>
        <span class="n">del_gendisk</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="p">);</span>
    <span class="c1">//...</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">my_block_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">delete_block_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">);</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As with character devices, it is recommended to use <code class="xref c c-type docutils literal"><span class="pre">my_block_dev</span></code>
structure to store important elements describing the block device.</p>
<p>Note that immediately after calling the <code class="xref c c-func docutils literal"><span class="pre">add_disk()</span></code> function (actually
even during the call), the disk is active and its methods can be called at any
time. As a result, this function should not be called before the driver is fully
initialized and ready to respond to requests for the registered disk.</p>
<p>It can be noticed that the basic structure in working with block devices (disks)
is the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span></code> structure.</p>
<p>After a call to <code class="xref c c-func docutils literal"><span class="pre">del_gendisk()</span></code>, the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span></code> structure
may continue to exist (and the device operations may still be called) if there
are still users (an open operation was called on the device but the associated
release operation has not been called). One solution is to keep the number of
users of the device and call the <code class="xref c c-func docutils literal"><span class="pre">del_gendisk()</span></code> function only when there
are no users left of the device.</p>
</div>
<div class="section" id="struct-gendisk-structure">
<h2><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span></code> structure<a class="headerlink" href="#struct-gendisk-structure" title="Permalink to this headline">¶</a></h2>
<p>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span></code> structure stores information about a disk. As
stated above, such a structure is obtained from the <code class="xref c c-func docutils literal"><span class="pre">alloc_disk()</span></code> call
and its fields must be filled before it is sent to the <code class="xref c c-func docutils literal"><span class="pre">add_disk()</span></code>
function.</p>
<p>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span></code> structure has the following important fields:</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-member docutils literal"><span class="pre">major</span></code>, <code class="xref c c-member docutils literal"><span class="pre">first_minor</span></code>, <code class="xref c c-member docutils literal"><span class="pre">minor</span></code>, describing
the identifiers used by the disk; a disk must have at least one minor; if
the disk allows the partitioning operation, a minor must be allocated for
each possible partition</li>
<li><code class="xref c c-member docutils literal"><span class="pre">disk_name</span></code>, which represents the disk name as it appears in
<code class="file docutils literal"><span class="pre">/proc/partitions</span></code> and in sysfs (<code class="file docutils literal"><span class="pre">/sys/block</span></code>)</li>
<li><code class="xref c c-member docutils literal"><span class="pre">fops</span></code>, representing operations associated with the disk</li>
<li><code class="xref c c-member docutils literal"><span class="pre">queue</span></code>, which represents the queue of requests</li>
<li><code class="xref c c-member docutils literal"><span class="pre">capacity</span></code>, which is disk capacity in 512 byte sectors;
it is initialized using the <code class="xref c c-func docutils literal"><span class="pre">set_capacity()</span></code> function</li>
<li><code class="xref c c-member docutils literal"><span class="pre">private_data</span></code>, which is a pointer to private data</li>
</ul>
</div></blockquote>
<p>An example of filling a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span></code> structure is presented below:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/genhd.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/blkdev.h&gt;</span><span class="cp"></span>

<span class="cp">#define NR_SECTORS                   1024</span>

<span class="cp">#define KERNEL_SECTOR_SIZE           512</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">my_block_dev</span> <span class="p">{</span>
    <span class="c1">//...</span>
    <span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>                <span class="cm">/* For mutual exclusion */</span>
    <span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>    <span class="cm">/* The device request queue */</span>
    <span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">gd</span><span class="p">;</span>             <span class="cm">/* The gendisk structure */</span>
    <span class="c1">//...</span>
<span class="p">}</span> <span class="n">dev</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_block_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_block_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="cm">/* Initialize the gendisk structure */</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span> <span class="o">=</span> <span class="n">alloc_disk</span><span class="p">(</span><span class="n">MY_BLOCK_MINORS</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printk</span> <span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;alloc_disk failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="o">-&gt;</span><span class="n">major</span> <span class="o">=</span> <span class="n">MY_BLOCK_MAJOR</span><span class="p">;</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="o">-&gt;</span><span class="n">first_minor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="o">-&gt;</span><span class="n">fops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_block_ops</span><span class="p">;</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">;</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
    <span class="n">snprintf</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="s">&quot;myblock&quot;</span><span class="p">);</span>
    <span class="n">set_capacity</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="p">,</span> <span class="n">NR_SECTORS</span><span class="p">);</span>

    <span class="n">add_disk</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_block_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
    <span class="c1">//...</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">create_block_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">status</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">delete_block_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_block_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">del_gendisk</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">//...</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">my_block_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">delete_block_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">);</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As stated before, the kernel considers a disk as a vector of 512 byte sectors.
In reality, the devices may have a different size of the sector. To work with
these devices, the kernel needs to be informed about the real size of a sector,
and for all operations the necessary conversions must be made.</p>
<p>To inform the kernel about the device sector size, a parameter of the request
queue must be set just after the request queue is allocated, using the
<code class="xref c c-func docutils literal"><span class="pre">blk_queue_logical_block_size()</span></code> function. All requests generated by the
kernel will be multiple of this sector size and will be aligned accordingly.
However, communication between the device and the driver will still be performed
in sectors of 512 bytes in size, so conversion should be done each time (an
example of such conversion is when calling the <code class="xref c c-func docutils literal"><span class="pre">set_capacity()</span></code> function
in the code above).</p>
</div>
<div class="section" id="struct-block-device-operations-structure">
<h2><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">block_device_operations</span></code> structure<a class="headerlink" href="#struct-block-device-operations-structure" title="Permalink to this headline">¶</a></h2>
<p>Just as for a character device, operations in <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file_operations</span></code>
should be completed, so for a block device, the operations in
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">block_device_operations</span></code> should be completed. The association
of operations is done through the <code class="xref c c-member docutils literal"><span class="pre">fops</span></code> field in the
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span></code>
structure.</p>
<p>Some of the fields of the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">block_device_operations</span></code> structure
are presented below:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">block_device_operations</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">fmode_t</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">,</span> <span class="n">fmode_t</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">locked_ioctl</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">fmode_t</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span>
                         <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ioctl</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">fmode_t</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">compat_ioctl</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">fmode_t</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span>
                         <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">direct_access</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">sector_t</span><span class="p">,</span>
                          <span class="kt">void</span> <span class="o">**</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">media_changed</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">revalidate_disk</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">getgeo</span><span class="p">)(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hd_geometry</span> <span class="o">*</span><span class="p">);</span>
    <span class="n">blk_qc_t</span> <span class="p">(</span><span class="o">*</span><span class="n">submit_bio</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="xref c c-func docutils literal"><span class="pre">open()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">release()</span></code> operations are called directly from user
space by utilities that may perform the following tasks: partitioning, file
system creation, file system verification. In a <code class="xref c c-func docutils literal"><span class="pre">mount()</span></code> operation, the
<code class="xref c c-func docutils literal"><span class="pre">open()</span></code> function is called directly from the kernel space, the file
descriptor being stored by the kernel. A driver for a block device can not
differentiate between <code class="xref c c-func docutils literal"><span class="pre">open()</span></code> calls performed from user space and kernel
space.</p>
<p>An example of how to use these two functions is given below:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/genhd.h&gt;</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">my_block_dev</span> <span class="p">{</span>
    <span class="c1">//...</span>
    <span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span> <span class="n">gd</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="p">}</span> <span class="n">dev</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_block_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//...</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_block_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">gd</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//...</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">block_device_operations</span> <span class="n">my_block_ops</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
    <span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">my_block_open</span><span class="p">,</span>
    <span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">my_block_release</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_block_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_block_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//....</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="o">-&gt;</span><span class="n">fops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_block_ops</span><span class="p">;</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Please notice that there are no read or write operations. These operations are
performed by the <code class="xref c c-func docutils literal"><span class="pre">request()</span></code> function associated with the request queue
of the disk.</p>
</div>
<div class="section" id="request-queues-multi-queue-block-layer">
<h2>Request Queues - Multi-Queue Block Layer<a class="headerlink" href="#request-queues-multi-queue-block-layer" title="Permalink to this headline">¶</a></h2>
<p>Drivers for block devices use queues to store the block I/O requests that will
be processed. A request queue is represented by the
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span></code> structure. The request queue is made up of a
double-linked list of requests and their associated control information. The
requests are added to the queue by higher-level kernel code (for example, file
systems).</p>
<p>The block device driver associates each queue with a handling function, which
will be called for each request in the queue
(the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code> structure).</p>
<p>In earlier version of the Linux kernel, each device driver had associated one or
more request queues (<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span></code>), where any client could add
requests, while also being able to reorder them.
The problem with this approach is that it requires a per-queue lock, making it
inefficient in distributed systems.</p>
<p>The <a class="reference external" href="https://www.kernel.org/doc/html/latest/block/blk-mq.html">Multi-Queue Block Queing Mechanism</a>
solves this issue by splitting the device driver queue in two parts:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Software staging queues</li>
<li>Hardware dispatch queues</li>
</ol>
</div></blockquote>
<div class="section" id="software-staging-queues">
<h3>Software staging queues<a class="headerlink" href="#software-staging-queues" title="Permalink to this headline">¶</a></h3>
<p>The staging queues hold requests from the clients before sending them to the
block device driver. To prevent the waiting for a per-queue lock, a staging
queue is allocated for each CPU or node. A software queue is associated to
only one hardware queue.</p>
<p>While in this queue, the requests can be merged or reordered, according to an
I/O Scheduler, in order to maximize performance. This means that only the
requests coming from the same CPU or node can be optimized.</p>
<p>Staging queues are usually not used by the block device drivers, but only
internally by the I/O subsystem to optimize requests before sending them to the
device drivers.</p>
</div>
<div class="section" id="hardware-dispatch-queues">
<h3>Hardware dispatch queues<a class="headerlink" href="#hardware-dispatch-queues" title="Permalink to this headline">¶</a></h3>
<p>The hardware queues (<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">blk_mq_hw_ctx</span></code>) are used to send the
requests from the staging queues to the block device driver.
Once in this queue, the requests can't be merged or reordered.</p>
<p>Depending on the underlying hardware, a block device driver can create multiple
hardware queues in order to improve parallelism and maximize performance.</p>
</div>
<div class="section" id="tag-sets">
<h3>Tag sets<a class="headerlink" href="#tag-sets" title="Permalink to this headline">¶</a></h3>
<p>A block device driver can accept a request before the previous one is completed.
As a consequence, the upper layers need a way to know when a request is
completed. For this, a &quot;tag&quot; is added to each request upon submission and sent
back using a completion notification after the request is completed.</p>
<p>The tags are part of a tag set (<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">blk_mq_tag_set</span></code>), which is
unique to a device.
The tag set structure is allocated and initialized before the request queues
and also stores some of the queues properties.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">blk_mq_tag_set</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">const</span> <span class="k">struct</span> <span class="n">blk_mq_ops</span>   <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span>               <span class="n">nr_hw_queues</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span>               <span class="n">queue_depth</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span>               <span class="n">cmd_size</span><span class="p">;</span>
  <span class="kt">int</span>                        <span class="n">numa_node</span><span class="p">;</span>
  <span class="kt">void</span>                      <span class="o">*</span><span class="n">driver_data</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">blk_mq_tags</span>       <span class="o">**</span><span class="n">tags</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">list_head</span>           <span class="n">tag_list</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Some of the fields in <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">blk_mq_tag_set</span></code> are:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">ops</span></code> - Queue operations, most notably the request handling function.</li>
<li><code class="docutils literal"><span class="pre">nr_hw_queues</span></code> - The number of hardware queues allocated for the device</li>
<li><code class="docutils literal"><span class="pre">queue_depth</span></code> - Hardware queues size</li>
<li><code class="docutils literal"><span class="pre">cmd_size</span></code> - Number of extra bytes allocated at the end of the device, to
be used by the block device driver, if needed.</li>
<li><code class="docutils literal"><span class="pre">numa_node</span></code> - In NUMA systems, the index of the node the storage device is
connected to.</li>
<li><code class="docutils literal"><span class="pre">driver_data</span></code> - Data private to the driver, if needed.</li>
<li><code class="docutils literal"><span class="pre">tags</span></code> - Pointer to an array of <code class="docutils literal"><span class="pre">nr_hw_queues</span></code> tag sets.</li>
<li><code class="docutils literal"><span class="pre">tag_list</span></code> - List of request queues using this tag set.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="create-and-delete-a-request-queue">
<h3>Create and delete a request queue<a class="headerlink" href="#create-and-delete-a-request-queue" title="Permalink to this headline">¶</a></h3>
<p>Request queues are created using the <code class="xref c c-func docutils literal"><span class="pre">blk_mq_init_queue()</span></code> function and
are deleted using <code class="xref c c-func docutils literal"><span class="pre">blk_cleanup_queue()</span></code>. The first function creates both
the hardware and the software queues and initializes their structures.</p>
<p>Queue properties, including the number of hardware queues, their capacity and
request handling function are configured using the <code class="xref c c-type docutils literal"><span class="pre">blk_mq_tag_set</span></code>
structure, as described above.</p>
<p>An example of using these functions is as follows:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/genhd.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/blkdev.h&gt;</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">my_block_dev</span> <span class="p">{</span>
    <span class="c1">//...</span>
    <span class="k">struct</span> <span class="n">blk_mq_tag_set</span> <span class="n">tag_set</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="p">}</span> <span class="n">dev</span><span class="p">;</span>

<span class="k">static</span> <span class="n">blk_status_t</span> <span class="nf">my_block_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">blk_mq_hw_ctx</span> <span class="o">*</span><span class="n">hctx</span><span class="p">,</span>
                                     <span class="k">const</span> <span class="k">struct</span> <span class="n">blk_mq_queue_data</span> <span class="o">*</span><span class="n">bd</span><span class="p">)</span>
<span class="c1">//...</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">blk_mq_ops</span> <span class="n">my_queue_ops</span> <span class="o">=</span> <span class="p">{</span>
   <span class="p">.</span><span class="n">queue_rq</span> <span class="o">=</span> <span class="n">my_block_request</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_block_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_block_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* Initialize tag set. */</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tag_set</span><span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_queue_ops</span><span class="p">;</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tag_set</span><span class="p">.</span><span class="n">nr_hw_queues</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tag_set</span><span class="p">.</span><span class="n">queue_depth</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tag_set</span><span class="p">.</span><span class="n">numa_node</span> <span class="o">=</span> <span class="n">NUMA_NO_NODE</span><span class="p">;</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tag_set</span><span class="p">.</span><span class="n">cmd_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tag_set</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">BLK_MQ_F_SHOULD_MERGE</span><span class="p">;</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">blk_mq_alloc_tag_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">tag_set</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Allocate queue. */</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">=</span> <span class="n">blk_mq_init_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">tag_set</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">goto</span> <span class="n">out_blk_init</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">blk_queue_logical_block_size</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">KERNEL_SECTOR_SIZE</span><span class="p">);</span>

     <span class="cm">/* Assign private data to queue structure. */</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">queuedata</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
    <span class="c1">//...</span>

<span class="nl">out_blk_init</span><span class="p">:</span>
    <span class="n">blk_mq_free_tag_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">tag_set</span><span class="p">);</span>
<span class="nl">out_err</span><span class="p">:</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_block_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
    <span class="c1">//...</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">create_block_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">status</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">delete_block_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//...</span>
    <span class="n">blk_cleanup_queue</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
    <span class="n">blk_mq_free_tag_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">tag_set</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">my_block_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">delete_block_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">);</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>After initializing the tag set structure, the tag lists are allocated using the
<code class="xref c c-func docutils literal"><span class="pre">blk_mq_alloc_tag_set()</span></code> function.
The pointer to the function which will process the requests
(<code class="xref c c-func docutils literal"><span class="pre">my_block_request()</span></code>) is filled in the <code class="docutils literal"><span class="pre">my_queue_ops</span></code> structure and
then the pointer to this structure is added to the tag set.</p>
<p>The queue is created using the <code class="xref c c-func docutils literal"><span class="pre">blk_mq_init_queue()</span></code> function, based on
the information added in the tag set.</p>
<p>As part of the request queue initialization, you can configure the
<code class="xref c c-member docutils literal"><span class="pre">queuedata</span></code> field, which is equivalent to the <code class="xref c c-member docutils literal"><span class="pre">private_data</span></code>
field in other structures.</p>
</div>
<div class="section" id="useful-functions-for-processing-request-queues">
<h3>Useful functions for processing request queues<a class="headerlink" href="#useful-functions-for-processing-request-queues" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">queue_rq</span></code> function from <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">blk_mq_ops</span></code> is used to handle
requests for working with the block device.
This function is the equivalent of read and write functions encountered on
character devices. The function receives the requests for the device as
arguments and can use various functions for processing them.</p>
<p>The functions used to process the requests in the handler are described below:</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-func docutils literal"><span class="pre">blk_mq_start_request()</span></code> - must be called before starting processing
a request;</li>
<li><code class="xref c c-func docutils literal"><span class="pre">blk_mq_requeue_request()</span></code> - to re-send the request in the queue;</li>
<li><code class="xref c c-func docutils literal"><span class="pre">blk_mq_end_request()</span></code> - to end request processing and notify the
upper layers.</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="requests-for-block-devices">
<h2>Requests for block devices<a class="headerlink" href="#requests-for-block-devices" title="Permalink to this headline">¶</a></h2>
<p>A request for a block device is described by <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code>
structure.</p>
<p>The fields of <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code> structure include:</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-member docutils literal"><span class="pre">cmd_flags</span></code>: a series of flags including direction (reading or
writing); to find out the direction, the macrodefinition
<code class="xref c c-macro docutils literal"><span class="pre">rq_data_dir</span></code> is used, which returns 0 for a read request and 1
for a write request on the device;</li>
<li><code class="xref c c-member docutils literal"><span class="pre">__sector</span></code>: the first sector of the transfer request; if the
device sector has a different size, the appropriate conversion should be
done. To access this field, use the <code class="xref c c-macro docutils literal"><span class="pre">blk_rq_pos</span></code> macro;</li>
<li><code class="xref c c-member docutils literal"><span class="pre">__data_len</span></code>: the total number of bytes to be transferred; to
access this field the <code class="xref c c-macro docutils literal"><span class="pre">blk_rq_bytes</span></code> macro is used;</li>
<li>generally, data from the current <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> will be
transferred; the data size is obtained using the
<code class="xref c c-macro docutils literal"><span class="pre">blk_rq_cur_bytes</span></code> macro;</li>
<li><code class="xref c c-member docutils literal"><span class="pre">bio</span></code>, a dynamic list of <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structures that
is a set of buffers associated to the request; this field is accessed by
macrodefinition <code class="xref c c-macro docutils literal"><span class="pre">rq_for_each_segment</span></code> if there are multiple
buffers, or by <code class="xref c c-macro docutils literal"><span class="pre">bio_data</span></code> macrodefinition in case there is only
one associated buffer;</li>
</ul>
</div></blockquote>
<p>We will discuss more about the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure and its
associated operations in the <span class="xref std std-ref">bio_structure</span> section.</p>
<div class="section" id="create-a-request">
<h3>Create a request<a class="headerlink" href="#create-a-request" title="Permalink to this headline">¶</a></h3>
<p>Read /write requests are created by code layers superior to the kernel I/O
subsystem. Typically, the subsystem that creates requests for block devices is
the file management subsystem. The I/O subsystem acts as an interface between
the file management subsystem and the block device driver. The main operations
under the responsibility of the I/O subsystem are adding requests to the queue
of the specific block device and sorting and merging requests according to
performance considerations.</p>
</div>
<div class="section" id="process-a-request">
<h3>Process a request<a class="headerlink" href="#process-a-request" title="Permalink to this headline">¶</a></h3>
<p>The central part of a block device driver is the request handling function
(<code class="docutils literal"><span class="pre">queue_rq</span></code>). In previous examples, the function that fulfilled this role was
<code class="xref c c-func docutils literal"><span class="pre">my_block_request()</span></code>. As stated in the
<a class="reference internal" href="#create-and-delete-a-request-queue">Create and delete a request queue</a> section, this function is associated to the
driver when creating the tag set structure.</p>
<p>This function is called when the kernel considers that the driver should process
I/O requests. The function must start processing the requests from the queue,
but it is not mandatory to finish them, as requests may be finished by other
parts of the driver.</p>
<p>The request function runs in an atomic context and must follow the rules for
atomic code (it does not need to call functions that can cause sleep, etc.).</p>
<p>Calling the function that processes the requests is asynchronous relative
to the actions of any userspace process and no assumptions about the process
in which the respective function is running should be made. Also, it should not
be assumed that the buffer provided by a request is from kernel space or user
space, any operation that accesses the userspace being erroneous.</p>
<p>One of the simplest request handling function is presented below:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">blk_status_t</span> <span class="nf">my_block_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">blk_mq_hw_ctx</span> <span class="o">*</span><span class="n">hctx</span><span class="p">,</span>
                                     <span class="k">const</span> <span class="k">struct</span> <span class="n">blk_mq_queue_data</span> <span class="o">*</span><span class="n">bd</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">my_block_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">queuedata</span><span class="p">;</span>

    <span class="n">blk_mq_start_request</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">blk_rq_is_passthrough</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">printk</span> <span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;Skip non-fs request</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="n">blk_mq_end_request</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">BLK_STS_IOERR</span><span class="p">);</span>
        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* do work */</span>
    <span class="p">...</span>

    <span class="n">blk_mq_end_request</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">BLK_STS_OK</span><span class="p">);</span>

<span class="nl">out</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">BLK_STS_OK</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="xref c c-func docutils literal"><span class="pre">my_block_request()</span></code> function performs the following operations:</p>
<blockquote>
<div><ul class="simple">
<li>Get a pointer to the request structure from the <code class="docutils literal"><span class="pre">bd</span></code> argument and start
its processing using the <code class="xref c c-func docutils literal"><span class="pre">blk_mq_start_request()</span></code> function.</li>
<li>A block device can receive calls which do not transfer data blocks (e.g.
low level operations on the disk, instructions referring to special ways of
accessing the device). Most drivers do not know how to handle these
requests and return an error.</li>
<li>To return an error, <code class="xref c c-func docutils literal"><span class="pre">blk_mq_end_request()</span></code> function is called,
<code class="docutils literal"><span class="pre">BLK_STS_IOERR</span></code> being the second argument.</li>
<li>The request is processed according to the needs of the associated device.</li>
<li>The request ends. In this case, <code class="xref c c-func docutils literal"><span class="pre">blk_mq_end_request()</span></code> function is
called in order to complete the request.</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="struct-bio-structure">
<h2><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure<a class="headerlink" href="#struct-bio-structure" title="Permalink to this headline">¶</a></h2>
<p>Each <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code> structure is an I/O block request, but may come
from combining more independent requests from a higher level. The sectors to be
transferred for a request can be scattered into the main memory but they always
correspond to a set of consecutive sectors on the device. The request is
represented as a series of segments, each corresponding to a buffer in memory.
The kernel can combine requests that refer to adjacent sectors but will not
combine write requests with read requests into a single
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code> structure.</p>
<p>A <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code> structure is implemented as a linked list of
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structures together with information that allows the
driver to retain its current position while processing the request.</p>
<p>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure is a low-level description of a portion of
a block I/O request.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">bio</span> <span class="p">{</span>
    <span class="c1">//...</span>
    <span class="k">struct</span> <span class="n">gendisk</span>          <span class="o">*</span><span class="n">bi_disk</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>            <span class="n">bi_opf</span><span class="p">;</span>         <span class="cm">/* bottom bits req flags, top bits REQ_OP. Use accessors. */</span>
    <span class="c1">//...</span>
    <span class="k">struct</span> <span class="n">bio_vec</span>          <span class="o">*</span><span class="n">bi_io_vec</span><span class="p">;</span>     <span class="cm">/* the actual vec list */</span>
    <span class="c1">//...</span>
    <span class="k">struct</span> <span class="n">bvec_iter</span>        <span class="n">bi_iter</span><span class="p">;</span>
    <span class="o">/</span><span class="p">...</span>
    <span class="kt">void</span>                    <span class="o">*</span><span class="n">bi_private</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In turn, the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure contains a <code class="xref c c-member docutils literal"><span class="pre">bi_io_vec</span></code>
vector of <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio_vec</span></code> structures. It consists of the individual
pages in the physical memory to be transferred, the offset within the page and
the size of the buffer. To iterate through a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure,
we need to iterate through the vector of <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio_vec</span></code> and transfer
the data from every physical page. To simplify vector iteration, the
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bvec_iter</span></code> structure is used. This structure maintains
information about how many buffers and sectors were consumed during the
iteration. The request type is encoded in the <code class="xref c c-member docutils literal"><span class="pre">bi_opf</span></code> field; to
determine it, use the <code class="xref c c-func docutils literal"><span class="pre">bio_data_dir()</span></code> function.</p>
<div class="section" id="create-a-struct-bio-structure">
<h3>Create a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure<a class="headerlink" href="#create-a-struct-bio-structure" title="Permalink to this headline">¶</a></h3>
<p>Two functions can be used to create a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure:</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-func docutils literal"><span class="pre">bio_alloc()</span></code>: allocates space for a new structure; the structure
must be initialized;</li>
<li><code class="xref c c-func docutils literal"><span class="pre">bio_clone()</span></code>: makes a copy of an existing <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code>
structure; the newly obtained structure is initialized with the values of
the cloned structure fields; the buffers are shared with the
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure that has been cloned so that access to the
buffers has to be done carefully to avoid access to the same memory area
from the two clones;</li>
</ul>
</div></blockquote>
<p>Both functions return a new <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure.</p>
</div>
<div class="section" id="submit-a-struct-bio-structure">
<h3>Submit a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure<a class="headerlink" href="#submit-a-struct-bio-structure" title="Permalink to this headline">¶</a></h3>
<p>Usually, a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure is created by the higher levels of
the kernel (usually the file system). A structure thus created is then
transmitted to the I/O subsystem that gathers more <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code>
structures into a request.</p>
<p>For submitting a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure to the associated I/O device
driver, the <code class="xref c c-func docutils literal"><span class="pre">submit_bio()</span></code> function is used. The function receives as
argument an initialized <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure that will be added to
a request from the request queue of an I/O device. From that queue, it can be
processed by the I/O device driver using a specialized function.</p>
</div>
<div class="section" id="wait-for-the-completion-of-a-struct-bio-structure">
<span id="bio-completion"></span><h3>Wait for the completion of a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure<a class="headerlink" href="#wait-for-the-completion-of-a-struct-bio-structure" title="Permalink to this headline">¶</a></h3>
<p>Submitting a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure to a driver has the effect of
adding it to a request from the request queue from where it will be further
processed. Thus, when the <code class="xref c c-func docutils literal"><span class="pre">submit_bio()</span></code> function returns, it is not
guaranteed that the processing of the structure has finished. If you want to
wait for the processing of the request to be finished, use the
<code class="xref c c-func docutils literal"><span class="pre">submit_bio_wait()</span></code> function.</p>
<p>To be notified when the processing of a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure ends
(when we do not use <code class="xref c c-func docutils literal"><span class="pre">submit_bio_wait()</span></code> function), the
<code class="xref c c-member docutils literal"><span class="pre">bi_end_io</span></code> field of the structure should be used. This field
specifies the function that will be called at the end of the
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure processing. You can use the
<code class="xref c c-member docutils literal"><span class="pre">bi_private</span></code> field of the structure to pass information to the
function.</p>
</div>
<div class="section" id="initialize-a-struct-bio-structure">
<h3>Initialize a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure<a class="headerlink" href="#initialize-a-struct-bio-structure" title="Permalink to this headline">¶</a></h3>
<p>Once a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure has been allocated and before being
transmitted, it must be initialized.</p>
<p>Initializing the structure involves filling in its important fields. As
mentioned above, the <code class="xref c c-member docutils literal"><span class="pre">bi_end_io</span></code> field is used to specify the function
called when the processing of the structure is finished. The
<code class="xref c c-member docutils literal"><span class="pre">bi_private</span></code> field is used to store useful data that can be accessed
in the function pointed by <code class="xref c c-member docutils literal"><span class="pre">bi_end_io</span></code>.</p>
<p>The <code class="xref c c-member docutils literal"><span class="pre">bi_opf</span></code> field specifies the type of operation.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bio_alloc</span><span class="p">(</span><span class="n">GFP_NOIO</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="c1">//...</span>
<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_disk</span> <span class="o">=</span> <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="p">;</span>
<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_iter</span><span class="p">.</span><span class="n">bi_sector</span> <span class="o">=</span> <span class="n">sector</span><span class="p">;</span>
<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_opf</span> <span class="o">=</span> <span class="n">REQ_OP_READ</span><span class="p">;</span>
<span class="n">bio_add_page</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
<span class="c1">//...</span>
</pre></div>
</div>
<p>In the code snippet above we specified the block device to which we sent the
following: <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure, startup sector, operation
(<code class="xref c c-data docutils literal"><span class="pre">REQ_OP_READ</span></code> or <code class="xref c c-data docutils literal"><span class="pre">REQ_OP_WRITE</span></code>) and content. The content of a
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure is a buffer described by: a physical page,
the offset in the page and the size of the bufer. A page can be assigned using
the <code class="xref c c-func docutils literal"><span class="pre">alloc_page()</span></code> call.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <code class="xref c c-data docutils literal"><span class="pre">size</span></code> field of the <code class="xref c c-func docutils literal"><span class="pre">bio_add_page()</span></code> call must be
a multiple of the device sector size.</p>
</div>
</div>
<div class="section" id="how-to-use-the-content-of-a-struct-bio-structure">
<span id="bio-content"></span><h3>How to use the content of a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure<a class="headerlink" href="#how-to-use-the-content-of-a-struct-bio-structure" title="Permalink to this headline">¶</a></h3>
<p>To use the content of a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure, the structure's
support pages must be mapped to the kernel address space from where they can be
accessed. For mapping /unmapping, use the <code class="xref c c-macro docutils literal"><span class="pre">kmap_atomic</span></code> and
the <code class="xref c c-macro docutils literal"><span class="pre">kunmap_atomic</span></code> macros.</p>
<p>A typical example of use is:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">my_block_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_block_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">start</span><span class="p">,</span>
                              <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_xfer_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_block_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">bio_vec</span> <span class="n">bvec</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">bvec_iter</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">bio_data_dir</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>

    <span class="cm">/* Do each segment independently. */</span>
    <span class="n">bio_for_each_segment</span><span class="p">(</span><span class="n">bvec</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sector_t</span> <span class="n">sector</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">bi_sector</span><span class="p">;</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">bvec</span><span class="p">.</span><span class="n">bv_page</span><span class="p">);</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">bvec</span><span class="p">.</span><span class="n">bv_offset</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">bvec</span><span class="p">.</span><span class="n">bv_len</span><span class="p">;</span>

        <span class="cm">/* process mapped buffer */</span>
        <span class="n">my_block_transfer</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sector</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">buffer</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>

        <span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As it can be seen from the example above, iterating through a
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> requires iterating through all of its segments. A segment
(<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio_vec</span></code>) is defined by the physical address page, the offset
in the page and its size.</p>
<p>To simplify the processing of a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code>, use the
<code class="xref c c-macro docutils literal"><span class="pre">bio_for_each_segment</span></code> macrodefinition. It will iterate through all
segments, and will also update global information stored in an iterator
(<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bvec_iter</span></code>) such as the current sector as well as other
internal information (segment vector index, number of bytes left to be
processed, etc.) .</p>
<p>You can store information in the mapped buffer, or extract information.</p>
<p>In case request queues are used and you needed to process the requests
at <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> level, use the <code class="xref c c-macro docutils literal"><span class="pre">rq_for_each_segment</span></code>
macrodefinition instead of the <code class="xref c c-macro docutils literal"><span class="pre">bio_for_each_segment</span></code> macrodefinition.
This macrodefinition iterates through each segment of each
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure of a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code> structure and
updates a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">req_iterator</span></code> structure. The
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">req_iterator</span></code> contains the current <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code>
structure and the iterator that traverses its segments.</p>
<p>A typical example of use is:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">bio_vec</span> <span class="n">bvec</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">req_iterator</span> <span class="n">iter</span><span class="p">;</span>

<span class="n">rq_for_each_segment</span><span class="p">(</span><span class="n">bvec</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sector_t</span> <span class="n">sector</span> <span class="o">=</span> <span class="n">iter</span><span class="p">.</span><span class="n">iter</span><span class="p">.</span><span class="n">bi_sector</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">bvec</span><span class="p">.</span><span class="n">bv_page</span><span class="p">);</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">bvec</span><span class="p">.</span><span class="n">bv_offset</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">bvec</span><span class="p">.</span><span class="n">bv_len</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">bio_data_dir</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">bio</span><span class="p">);</span>

    <span class="n">my_block_transfer</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sector</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">buffer</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>

    <span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="free-a-struct-bio-structure">
<h3>Free a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure<a class="headerlink" href="#free-a-struct-bio-structure" title="Permalink to this headline">¶</a></h3>
<p>Once a kernel subsystem uses a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure, it will have to
release the reference to it. This is done by calling <code class="xref c c-func docutils literal"><span class="pre">bio_put()</span></code> function.</p>
</div>
<div class="section" id="set-up-a-request-queue-at-struct-bio-level">
<h3>Set up a request queue at <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> level<a class="headerlink" href="#set-up-a-request-queue-at-struct-bio-level" title="Permalink to this headline">¶</a></h3>
<p>We have previously seen how we can specify a function to be used to process
requests sent to the driver. The function receives as argument the requests and
carries out processing at <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code> level.</p>
<p>If, for flexibility reasons, we need to specify a function that carries
out processing at <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure level, we no longer
use request queues and we will need to fill the <code class="docutils literal"><span class="pre">submit_bio</span></code> field in the
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">block_device_operations</span></code> associated to the driver.</p>
<p>Below is a typical example of initializing a function that carries out
processing at <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure level:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="c1">// the declaration of the function that carries out processing</span>
<span class="c1">// :c:type:`struct bio` structures</span>
<span class="k">static</span> <span class="n">blk_qc_t</span> <span class="nf">my_submit_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">block_device_operations</span> <span class="n">my_block_ops</span> <span class="o">=</span> <span class="p">{</span>
   <span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
   <span class="p">.</span><span class="n">submit_bio</span> <span class="o">=</span> <span class="n">my_submit_bio</span>
   <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="further-reading">
<h2>Further reading<a class="headerlink" href="#further-reading" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference external" href="http://static.lwn.net/images/pdf/LDD3/ch16.pdf">Linux Device Drivers 3rd Edition, Chapter 16. Block Drivers</a></li>
<li>Linux Kernel Development, Second Edition – Chapter 13. The Block I/O Layer</li>
<li><a class="reference external" href="https://lwn.net/Articles/58719/">A simple block driver</a></li>
<li><a class="reference external" href="https://lwn.net/Articles/25711/">The gendisk interface</a></li>
<li><a class="reference external" href="https://lwn.net/Articles/26404/">The bio structure</a></li>
<li><a class="reference external" href="https://lwn.net/Articles/27055/">Request queues</a></li>
<li><a class="reference external" href="https://elixir.bootlin.com/linux/v4.15/source/Documentation/block/request.txt">Documentation/block/request.txt - Struct request documentation</a></li>
<li><a class="reference external" href="https://elixir.bootlin.com/linux/v4.15/source/Documentation/block/biodoc.txt">Documentation/block/biodoc.txt - Notes on the Generic Block Layer</a></li>
<li><a class="reference external" href="https://elixir.bootlin.com/linux/v4.15/source/drivers/block/brd.c">drivers/block/brd/c - RAM backed block disk driver</a></li>
<li><a class="reference external" href="https://www.linuxjournal.com/article/6931">I/O Schedulers</a></li>
</ul>
</div>
<div class="section" id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p>To solve exercises, you need to perform these steps:</p>
<blockquote>
<div><ul class="simple">
<li>prepare skeletons from templates</li>
<li>build modules</li>
<li>copy modules to the VM</li>
<li>start the VM and test the module in the VM.</li>
</ul>
</div></blockquote>
<p>The current lab name is block_device_drivers. See the exercises for the task name.</p>
<p>The skeleton code is generated from full source examples located in
<code class="file docutils literal"><span class="pre">tools/labs/templates</span></code>. To solve the tasks, start by generating
the skeleton code for a complete lab:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make clean
tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt; make skels
</pre></div>
</div>
<p>You can also generate the skeleton for a single task, using</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt;/&lt;task name&gt; make skels
</pre></div>
</div>
<p>Once the skeleton drivers are generated, build the source:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make build
</pre></div>
</div>
<p>Then, copy the modules and start the VM:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make copy
tools/labs $ make boot
</pre></div>
</div>
<p>The modules are placed in /home/root/skels/block_device_drivers/&lt;task_name&gt;.</p>
<p>Alternatively, we can copy files via <strong class="command">scp</strong>, in order to avoid restarting the VM.
For additional details about connecting to the VM via the network, please check <a class="reference internal" href="../info/vm.html#vm-interaction-link"><span class="std std-ref">Connecting to the Virtual Machine</span></a>.</p>
<p class="last">Review the <a class="reference internal" href="#exercises">Exercises</a> section for more detailed information.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>Before starting the exercises or generating the skeletons, please run <strong>git pull</strong> inside the Linux repo,
to make sure you have the latest version of the exercises.</p>
<p>If you have local changes, the pull command will fail. Check for local changes using <code class="docutils literal"><span class="pre">git</span> <span class="pre">status</span></code>.
If you want to keep them, run <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span></code> before <code class="docutils literal"><span class="pre">pull</span></code> and <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span> <span class="pre">pop</span></code> after.
To discard the changes, run <code class="docutils literal"><span class="pre">git</span> <span class="pre">reset</span> <span class="pre">--hard</span> <span class="pre">master</span></code>.</p>
<p class="last">If you already generated the skeleton before <code class="docutils literal"><span class="pre">git</span> <span class="pre">pull</span></code> you will need to generate it again.</p>
</div>
<div class="section" id="intro">
<h3>0. Intro<a class="headerlink" href="#intro" title="Permalink to this headline">¶</a></h3>
<p>Using <a class="reference external" href="http://elixir.free-electrons.com/linux/latest/source">LXR</a> find the definitions of the following symbols in the Linux kernel:</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code></li>
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio_vec</span></code></li>
<li><code class="xref c c-macro docutils literal"><span class="pre">bio_for_each_segment</span></code></li>
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span></code></li>
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">block_device_operations</span></code></li>
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="block-device">
<h3>1. Block device<a class="headerlink" href="#block-device" title="Permalink to this headline">¶</a></h3>
<p>Create a kernel module that allows you to register or deregister a block device.
Start from the files in the <code class="file docutils literal"><span class="pre">1-2-3-6-ram-disk/kernel</span></code> directory in the
lab skeleton.</p>
<p>Follow the comments marked with <strong>TODO 1</strong> in the laboratory skeleton. Use the
existing macrodefinitions (<code class="xref c c-macro docutils literal"><span class="pre">MY_BLOCK_MAJOR</span></code>,
<code class="xref c c-macro docutils literal"><span class="pre">MY_BLKDEV_NAME</span></code>). Check the value returned by the register function,
and in case of error, return the error code.</p>
<p>Compile the module, copy it to the virtual machine and insert it into the
kernel. Verify that your device was successfully created inside the
<code class="file docutils literal"><span class="pre">/proc/devices</span></code>.
You will see a device with major 240.</p>
<p>Unload the kernel module and check that the device was unregistered.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">Review the <a class="reference internal" href="#register-a-block-i-o-device">Register a block I/O device</a> section.</p>
</div>
<p>Change the <code class="xref c c-macro docutils literal"><span class="pre">MY_BLOCK_MAJOR</span></code> value to 7. Compile the module, copy it to
the virtual machine, and insert it into the kernel. Notice that the insertion
fails because there is already another driver/device registered in the kernel
with the major 7.</p>
<p>Restore the 240 value for the <code class="xref c c-macro docutils literal"><span class="pre">MY_BLOCK_MAJOR</span></code> macro.</p>
</div>
<div class="section" id="disk-registration">
<h3>2. Disk registration<a class="headerlink" href="#disk-registration" title="Permalink to this headline">¶</a></h3>
<p>Modify the previous module to add a disk associated with the driver. Analyze the
macrodefinitions, <code class="xref c c-type docutils literal"><span class="pre">my_block_dev</span></code> structure and existing functions from
the <code class="file docutils literal"><span class="pre">ram-disk.c</span></code> file.</p>
<p>Follow the comments marked with <strong>TODO 2</strong>. Use the
<code class="xref c c-func docutils literal"><span class="pre">create_block_device()</span></code> and the <code class="xref c c-func docutils literal"><span class="pre">delete_block_device()</span></code> functions.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">Review the <a class="reference internal" href="#register-a-disk">Register a disk</a> and <a class="reference internal" href="#process-a-request">Process a request</a> sections.</p>
</div>
<p>Fill in the <code class="xref c c-func docutils literal"><span class="pre">my_block_request()</span></code> function to process the request
without actually processing your request: display the &quot;request received&quot; message
and the following information: start sector, total size, data size from the
current <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure, direction. To validate a request type,
use the <code class="xref c c-func docutils literal"><span class="pre">blk_rq_is_passthrough()</span></code> (the function returns 0 in the case in
which we are interested, i.e. when the request is generated by the file system).</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">To find the needed info, review the <a class="reference internal" href="#requests-for-block-devices">Requests for block devices</a>
section.</p>
</div>
<p>Use the <code class="xref c c-func docutils literal"><span class="pre">blk_mq_end_request()</span></code> function to finish processing the
request.</p>
<p>Insert the module into the kernel and inspect the messages printed
by the module. When a device is added, a request is sent to the device. Check
the presence of <code class="file docutils literal"><span class="pre">/dev/myblock</span></code> and if it doesn't exist, create the device
using the command:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>mknod /dev/myblock b <span class="m">240</span> <span class="m">0</span>
</pre></div>
</div>
<p>To generate writing requests, use the command:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span><span class="nb">echo</span> <span class="s2">&quot;abc&quot;</span>&gt; /dev/myblock
</pre></div>
</div>
<p>Notice that a write request is preceded by a read request. The request
is done to read the block from the disk and &quot;update&quot; its content with the
data provided by the user, without overwriting the rest. After reading and
updating, writing takes place.</p>
</div>
<div class="section" id="ram-disk">
<h3>3. RAM disk<a class="headerlink" href="#ram-disk" title="Permalink to this headline">¶</a></h3>
<p>Modify the previous module to create a RAM disk: requests to the device will
result in reads/writes in a memory area.</p>
<p>The memory area <code class="xref c c-data docutils literal"><span class="pre">dev-&gt;data</span></code> is already allocated in the source code of
the module using <code class="xref c c-func docutils literal"><span class="pre">vmalloc()</span></code> and deallocated using <code class="xref c c-func docutils literal"><span class="pre">vfree()</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Review the <a class="reference internal" href="#process-a-request">Process a request</a> section.</p>
</div>
<p>Follow the comments marked with <strong>TODO 3</strong> to complete the
<code class="xref c c-func docutils literal"><span class="pre">my_block_transfer()</span></code> function to write/read the request information
in/from the memory area. The function will be called for each request within
the queue processing function: <code class="xref c c-func docutils literal"><span class="pre">my_block_request()</span></code>. To write/read
to/from the memory area, use <code class="xref c c-func docutils literal"><span class="pre">memcpy()</span></code>. To determine the write/read
information, use the fields of the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code> structure.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">To find out the size of the request data, use the
<code class="xref c c-macro docutils literal"><span class="pre">blk_rq_cur_bytes</span></code> macro. Do not use the
<code class="xref c c-macro docutils literal"><span class="pre">blk_rq_bytes</span></code> macro.</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">To find out the buffer associated to the request, use
<code class="xref c c-data docutils literal"><span class="pre">bio_data`(:c:data:`rq-&gt;bio</span></code>).</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">A description of useful macros is in the <a class="reference internal" href="#requests-for-block-devices">Requests for block devices</a>
section.</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">You can find useful information in the
<a class="reference external" href="https://github.com/martinezjavier/ldd3/blob/master/sbull/sbull.c">block device driver example</a>
from <a class="reference external" href="http://lwn.net/Kernel/LDD3/">Linux Device Driver</a>.</p>
</div>
<p>For testing, use the test file <code class="file docutils literal"><span class="pre">user/ram-disk-test.c</span></code>.
The test program is compiled automatically at <code class="docutils literal"><span class="pre">make</span> <span class="pre">build</span></code>, copied to the
virtual machine at <code class="docutils literal"><span class="pre">make</span> <span class="pre">copy</span></code> and can be run on the QEMU virtual machine
using the command:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>./ram-disk-test
</pre></div>
</div>
<p>There is no need to insert the module into the kernel, it will be inserted by
the <code class="docutils literal"><span class="pre">ram-disk-test</span></code> command.</p>
<p>Some tests may fail because of lack of synchronization between the transmitted
data (flush).</p>
</div>
<div class="section" id="read-data-from-the-disk">
<h3>4. Read data from the disk<a class="headerlink" href="#read-data-from-the-disk" title="Permalink to this headline">¶</a></h3>
<p>The purpose of this exercise is to read data from the
<code class="xref c c-macro docutils literal"><span class="pre">PHYSICAL_DISK_NAME</span></code> disk (<code class="file docutils literal"><span class="pre">/dev/vdb</span></code>) directly from the kernel.</p>
<div class="admonition attention">
<p class="first admonition-title">Attention</p>
<p>Before solving the exercise, we need to make sure the disk is
added to the virtual machine.</p>
<p>Check the variable <code class="docutils literal"><span class="pre">QEMU_OPTS</span></code> from <code class="file docutils literal"><span class="pre">qemu/Makefile</span></code>.
There should already be two extra disks added using <code class="docutils literal"><span class="pre">-drive</span> <span class="pre">...</span></code>.</p>
<p class="last">If there are not, generate a file that we will use as
the disk image using the command:
<strong class="command">dd if=/dev/zero of=qemu/mydisk.img bs=1024 count=1</strong>
and add the following option:
<strong class="command">-drive file=qemu/mydisk.img,if=virtio,format=raw</strong>
to <code class="file docutils literal"><span class="pre">qemu/Makefile</span></code> (in the <code class="xref c c-data docutils literal"><span class="pre">QEMU_OPTS</span></code> variable,
after the root disk).</p>
</div>
<p>Follow the comments marked with <strong>TODO 4</strong> in the directory <code class="file docutils literal"><span class="pre">4-5-relay/</span></code>
and implement <code class="xref c c-func docutils literal"><span class="pre">open_disk()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">close_disk()</span></code>.
Use the <code class="xref c c-func docutils literal"><span class="pre">blkdev_get_by_path()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">blkdev_put()</span></code> functions. The
device must be opened in read-write mode exclusively
(<code class="xref c c-macro docutils literal"><span class="pre">FMODE_READ</span></code> | <code class="xref c c-macro docutils literal"><span class="pre">FMODE_WRITE</span></code> | <code class="xref c c-macro docutils literal"><span class="pre">FMODE_EXCL</span></code>), and
as holder you must use the current module (<code class="xref c c-macro docutils literal"><span class="pre">THIS_MODULE</span></code>).</p>
<p>Implement the <code class="xref c c-func docutils literal"><span class="pre">send_test_bio()</span></code> function. You will have to create a new
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure and fill it, submit it and wait for it. Read the
first sector of the disk. To wait, call the <code class="xref c c-func docutils literal"><span class="pre">submit_bio_wait()</span></code> function.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p>The first sector of the disk is the sector with the index 0.
This value must be used to initialize the field
<code class="xref c c-member docutils literal"><span class="pre">bi_iter.bi_sector</span></code> of the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code>.</p>
<p class="last">For the read operation, use the <code class="xref c c-macro docutils literal"><span class="pre">REQ_OP_READ</span></code> macro to
initialize the <code class="xref c c-member docutils literal"><span class="pre">bi_opf</span></code> field of the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code>.</p>
</div>
<p>After finishing the operation, display the first 3 bytes of data read by
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure. Use the format <code class="docutils literal"><span class="pre">&quot;%</span> <span class="pre">02x&quot;</span></code> for <code class="xref c c-func docutils literal"><span class="pre">printk()</span></code>
to display the data and the <code class="xref c c-macro docutils literal"><span class="pre">kmap_atomic</span></code> and <code class="xref c c-macro docutils literal"><span class="pre">kunmap_atomic</span></code>
macros respectively.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">As an argument for the <code class="xref c c-func docutils literal"><span class="pre">kmap_atomic()</span></code> function, just use the
page which is allocated above in the code, in the <code class="xref c c-data docutils literal"><span class="pre">page</span></code>
variable.</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">Review the sections <a class="reference internal" href="#bio-content"><span class="std std-ref">How to use the content of a struct bio structure</span></a> and <a class="reference internal" href="#bio-completion"><span class="std std-ref">Wait for the completion of a struct bio structure</span></a>.</p>
</div>
<p>For testing, use the <code class="file docutils literal"><span class="pre">test-relay-disk</span></code> script, which is copied on the
virtual machine when running <strong class="command">make copy</strong>. If it is not copied, make
sure it is executable:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>chmod +x test-relay-disk
</pre></div>
</div>
<p>There is no need to load the module into the kernel, it will be loaded by
<strong class="command">test-relay-disk</strong>.</p>
<p>Use the command below to run the script:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>./test-relay-disk
</pre></div>
</div>
<p>The script writes &quot;abc&quot; at the beginning of the disk indicated by
<code class="xref c c-macro docutils literal"><span class="pre">PHYSICAL_DISK_NAME</span></code>. After running, the module will display 61 62 63
(the corresponding hexadecimal values of letters &quot;a&quot;, &quot;b&quot; and &quot;c&quot;).</p>
</div>
<div class="section" id="write-data-to-the-disk">
<h3>5. Write data to the disk<a class="headerlink" href="#write-data-to-the-disk" title="Permalink to this headline">¶</a></h3>
<p>Follow the comments marked with <strong>TODO 5</strong> to write a message
(<code class="xref c c-macro docutils literal"><span class="pre">BIO_WRITE_MESSAGE</span></code>) on the disk.</p>
<p>The <code class="xref c c-func docutils literal"><span class="pre">send_test_bio()</span></code> function receives as argument the operation type
(read or write). Call in the <code class="xref c c-func docutils literal"><span class="pre">relay_init()</span></code> function the function for
reading and in the <code class="xref c c-func docutils literal"><span class="pre">relay_exit()</span></code> function the function for writing. We
recommend using the <code class="xref c c-macro docutils literal"><span class="pre">REQ_OP_READ</span></code> and the <code class="xref c c-macro docutils literal"><span class="pre">REQ_OP_WRITE</span></code>
macros.</p>
<p>Inside the <code class="xref c c-func docutils literal"><span class="pre">send_test_bio()</span></code> function, if the operation is write, fill in
the buffer associated to the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure with the message
<code class="xref c c-macro docutils literal"><span class="pre">BIO_WRITE_MESSAGE</span></code>. Use the <code class="xref c c-macro docutils literal"><span class="pre">kmap_atomic</span></code> and the
<code class="xref c c-macro docutils literal"><span class="pre">kunmap_atomic</span></code> macros to work with the buffer associated to the
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">You need to update the type of the operation associated to the
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure by setting the <code class="xref c c-member docutils literal"><span class="pre">bi_opf</span></code> field
accordingly.</p>
</div>
<p>For testing, run the <code class="file docutils literal"><span class="pre">test-relay-disk</span></code> script using the command:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>./test-relay-disk
</pre></div>
</div>
<p>The script will display the <code class="docutils literal"><span class="pre">&quot;read</span> <span class="pre">from</span> <span class="pre">/dev/sdb:</span> <span class="pre">64</span> <span class="pre">65</span> <span class="pre">66&quot;</span></code> message at the
standard output.</p>
</div>
<div class="section" id="processing-requests-from-the-request-queue-at-struct-bio-level">
<h3>6. Processing requests from the request queue at <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> level<a class="headerlink" href="#processing-requests-from-the-request-queue-at-struct-bio-level" title="Permalink to this headline">¶</a></h3>
<p>In the implementation from Exercise 3, we have only processed a
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio_vec</span></code> of the current <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> from the request.
We want to process all <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio_vec</span></code> structures from all
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structures.
For this, we will iterate through all <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> requests and through
all <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio_vec</span></code> structures (also called segments) of each
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code>.</p>
<p>Add, within the ramdisk implementation (<code class="file docutils literal"><span class="pre">1-2-3-6-ram-disk/</span></code> directory),
support for processing the requests from the request queue at
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> level. Follow the comments marked with <strong>TODO 6</strong>.</p>
<p>Set the <code class="xref c c-macro docutils literal"><span class="pre">USE_BIO_TRANSFER</span></code> macro to 1.</p>
<p>Implement the <code class="xref c c-func docutils literal"><span class="pre">my_xfer_request()</span></code> function. Use the
<code class="xref c c-macro docutils literal"><span class="pre">rq_for_each_segment</span></code> macro to iterate through the <code class="xref c c-type docutils literal"><span class="pre">bio_vec</span></code>
structures of each <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> from the request.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">Review the indications and the code snippets from the
<a class="reference internal" href="#bio-content"><span class="std std-ref">How to use the content of a struct bio structure</span></a> section.</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">Use the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> segment iterator to get the current
sector (<code class="xref c c-member docutils literal"><span class="pre">iter.iter.bi_sector</span></code>).</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">Use the request iterator to get the reference to the current
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> (<code class="xref c c-member docutils literal"><span class="pre">iter.bio</span></code>).</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">Use the <code class="xref c c-macro docutils literal"><span class="pre">bio_data_dir</span></code> macro to find the reading or writing
direction for a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code>.</p>
</div>
<p>Use the <code class="xref c c-macro docutils literal"><span class="pre">kmap_atomic</span></code> or the <code class="xref c c-macro docutils literal"><span class="pre">kunmap_atomic</span></code> macros to map
the pages of each <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure and access its associated
buffers. For the actual transfer, call the <code class="xref c c-func docutils literal"><span class="pre">my_block_transfer()</span></code> function
implemented in the previous exercise.</p>
<p>For testing, use the <code class="file docutils literal"><span class="pre">ram-disk-test.c</span></code> test file:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>./ram-disk-test
</pre></div>
</div>
<p>There is no need to insert the module into the kernel, it will be inserted by
the <strong class="command">ram-disk-test</strong> executable.</p>
<p>Some tests may crash because of lack of synchronization between the transmitted
data (flush).</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="lab6-memory-mapping.html" class="btn btn-neutral float-left" title="SO2 Lab 06 - Memory Mapping" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="lab8-filesystems-part1.html" class="btn btn-neutral float-right" title="SO2 Lab 08 - File system drivers (Part 1)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright The kernel development community.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>