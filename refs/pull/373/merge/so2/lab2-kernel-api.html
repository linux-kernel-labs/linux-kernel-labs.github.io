<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SO2 Lab 02 - Kernel API &mdash; The Linux Kernel  documentation</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/asciinema-player.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
      <script>
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/asciinema-player.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="SO2 Lab 03 - Character device drivers" href="lab3-device-drivers.html" />
    <link rel="prev" title="SO2 Lab 01 - Introduction" href="lab1-intro.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            The Linux Kernel
          </a>
              <div class="version">
                5.10.14
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Operating Systems 2</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="lec1-intro.html">SO2 Lecture 01 - Course overview and Linux kernel introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec2-syscalls.html">SO2 Lecture 02 - System calls</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec3-processes.html">SO2 Lecture 03 - Processes</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec4-interrupts.html">SO2 Lecture 04 - Interrupts</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec5-smp.html">SO2 Lecture 05 - Symmetric Multi-Processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec6-address-space.html">SO2 Lecture 06 - Address Space</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec7-memory-management.html">SO2 Lecture 07 - Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec8-filesystems.html">SO2 Lecture 08 - Filesystem Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec9-debugging.html">SO2 Lecture 09 - Kernel debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec10-networking.html">SO2 Lecture 10 - Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec11-arch.html">SO2 Lecture 11 - Architecture Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec12-virtualization.html">SO2 Lecture 12 - Virtualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab1-intro.html">SO2 Lab 01 - Introduction</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">SO2 Lab 02 - Kernel API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#lab-objectives">Lab objectives</a></li>
<li class="toctree-l3"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#accessing-memory">Accessing memory</a></li>
<li class="toctree-l3"><a class="reference internal" href="#contexts-of-execution">Contexts of execution</a></li>
<li class="toctree-l3"><a class="reference internal" href="#locking">Locking</a></li>
<li class="toctree-l3"><a class="reference internal" href="#preemptivity">Preemptivity</a></li>
<li class="toctree-l3"><a class="reference internal" href="#linux-kernel-api">Linux Kernel API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#convention-indicating-errors">Convention indicating errors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#strings-of-characters">Strings of characters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#printk">printk</a></li>
<li class="toctree-l4"><a class="reference internal" href="#memory-allocation">Memory allocation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#lists">lists</a></li>
<li class="toctree-l4"><a class="reference internal" href="#spinlock">Spinlock</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mutex">mutex</a></li>
<li class="toctree-l4"><a class="reference internal" href="#atomic-variables-1">Atomic variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="#atomic-bitwise-operations">Atomic bitwise operations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#exercises">Exercises</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#intro">0. Intro</a></li>
<li class="toctree-l4"><a class="reference internal" href="#memory-allocation-in-linux-kernel">1. Memory allocation in Linux kernel</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sleeping-in-atomic-context">2. Sleeping in atomic context</a></li>
<li class="toctree-l4"><a class="reference internal" href="#working-with-kernel-memory">3. Working with kernel memory</a></li>
<li class="toctree-l4"><a class="reference internal" href="#working-with-kernel-lists">4. Working with kernel lists</a></li>
<li class="toctree-l4"><a class="reference internal" href="#working-with-kernel-lists-for-process-handling">5. Working with kernel lists for process handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="#synchronizing-list-work">6. Synchronizing list work</a></li>
<li class="toctree-l4"><a class="reference internal" href="#test-module-calling-in-our-list-module">7. Test module calling in our list module</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lab3-device-drivers.html">SO2 Lab 03 - Character device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab4-interrupts.html">SO2 Lab 04 - I/O access and Interrupts</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab5-deferred-work.html">SO2 Lab 05 - Deferred work</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab6-memory-mapping.html">SO2 Lab 06 - Memory Mapping</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab7-block-device-drivers.html">SO2 Lab 07 - Block Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab8-filesystems-part1.html">SO2 Lab 08 - File system drivers (Part 1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab9-filesystems-part2.html">SO2 Lab 09 - File system drivers (Part 2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab10-networking.html">SO2 Lab 10 - Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab11-arm-kernel-development.html">SO2 Lab 11 - Kernel Development on ARM</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab12-kernel-profiling.html">SO2 Lab 12 - Kernel Profiling</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign-collaboration.html">Collaboration</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign0-kernel-api.html">Assignment 0 - Kernel API</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign1-kprobe-based-tracer.html">Assignment 1 - Kprobe based tracer</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign2-driver-uart.html">Assignment 2 - Driver UART</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign3-software-raid.html">Assignment 3 - Software RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign4-transport-protocol.html">Assignment 4 - SO2 Transport Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign7-kvm-vmm.html">Assignment 7 - SO2 Virtual Machine Manager with KVM</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Lectures</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../lectures/intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/syscalls.html">System Calls</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/interrupts.html">Interrupts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/smp.html">Symmetric Multi-Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/address-space.html">Address Space</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/memory-management.html">Memory Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/fs.html">Filesystem Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/debugging.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/networking.html">Network Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/arch.html">Architecture Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/virt.html">Virtualization</a></li>
</ul>
<p class="caption"><span class="caption-text">Labs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../labs/infrastructure.html">Infrastructure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_modules.html">Kernel modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_api.html">Kernel API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/device_drivers.html">Character device drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/interrupts.html">I/O access and Interrupts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/deferred_work.html">Deferred work</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/block_device_drivers.html">Block Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/filesystems_part1.html">File system drivers (Part 1)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/filesystems_part2.html">File system drivers (Part 2)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/networking.html">Networking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/arm_kernel_development.html">Kernel Development on ARM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/memory_mapping.html">Memory mapping</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/device_model.html">Linux Device Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_profiling.html">Kernel Profiling</a></li>
</ul>
<p class="caption"><span class="caption-text">Useful info</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../info/vm.html">Virtual Machine Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/extra-vm.html">Customizing the Virtual Machine Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/contributing.html">Contributing to linux-kernel-labs</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Operating Systems 2</a></li>
      <li class="breadcrumb-item active">SO2 Lab 02 - Kernel API</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/so2/lab2-kernel-api.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="so2-lab-02-kernel-api">
<h1>SO2 Lab 02 - Kernel API<a class="headerlink" href="#so2-lab-02-kernel-api" title="Permalink to this headline">¶</a></h1>
<div class="section" id="lab-objectives">
<h2>Lab objectives<a class="headerlink" href="#lab-objectives" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li>Familiarize yourself with the basic Linux kernel API</li>
<li>Description of memory allocation mechanisms</li>
<li>Description of locking mechanisms</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>Inside the current lab we present a set of concepts and basic functions required
for starting Linux kernel programming. It is important to note that kernel
programming differs greatly from user space programming. The kernel is a
stand-alone entity that can not use libraries in user-space (not even libc).
As a result, the usual user-space functions (printf, malloc, free, open, read,
write, memcpy, strcpy, etc.) can no longer be used. In conclusion, kernel
programming is based on a totally new and independent API that is unrelated to
the user-space API, whether we refer to POSIX or ANSI C (standard C language
library functions).</p>
</div>
<div class="section" id="accessing-memory">
<h2>Accessing memory<a class="headerlink" href="#accessing-memory" title="Permalink to this headline">¶</a></h2>
<p>An important difference in kernel programming is how to access and allocate
memory. Due to the fact that kernel programming is very close to the physical
machine, there are important rules for memory management. First, it works with
several types of memory:</p>
<blockquote>
<div><ul class="simple">
<li>Physical memory</li>
<li>Virtual memory from the kernel address space</li>
<li>Virtual memory from a process's address space</li>
<li>Resident memory - we know for sure that the accessed pages are present in
physical memory</li>
</ul>
</div></blockquote>
<p>Virtual memory in a process's address space can not be considered resident due
to the virtual memory mechanisms implemented by the operating system: pages may
be swapped or simply may not be present in physical memory as a result of the
demand paging mechanism. The memory in the kernel address space can be resident
or not. Both the data and code segments of a module and the kernel stack of a
process are resident. Dynamic memory may or may not be resident, depending on
how it is allocated.</p>
<p>When working with resident memory, things are simple: memory can be accessed at
any time. But if working with non-resident memory, then it can only be accessed
from certain contexts. Non-resident memory can only be accessed from the
process context. Accessing non-resident memory from the context of an
interrupt has unpredictable results and, therefore, when the operating
system detects such access, it will take drastic measures: blocking or
resetting the system to prevent serious corruption.</p>
<p>The virtual memory of a process can not be accessed directly from the kernel.
In general, it is totally discouraged to access the address space of a process,
but there are situations where a device driver needs to do it. The typical case
is where the device driver needs to access a buffer from the user-space. In
this case, the device driver must use special features and not directly access
the buffer. This is necessary to prevent access to invalid memory areas.</p>
<p>Another difference from the user-space scheduling, relative to memory, is due to
the stack, a stack whose size is fixed and limited. A stack of 4K is used in
Linux, and a stack of 12K is used in Windows. For this reason, the
allocation of large structures on stack or the use of recursive calls should
be avoided.</p>
</div>
<div class="section" id="contexts-of-execution">
<h2>Contexts of execution<a class="headerlink" href="#contexts-of-execution" title="Permalink to this headline">¶</a></h2>
<p>In relation to kernel execution, we distinguish two contexts: process context
and interrupt context. We are in the process context when we run code as a
result of a system call or when we run in the context of a kernel thread. When
we run in a routine to handle an interrupt or a deferrable action, we run in
an interrupt context.</p>
<p>Some of the kernel API calls can block the current process. Common examples are
using a semaphore or waiting for a condition. In this case, the process is
put into the <code class="docutils literal"><span class="pre">WAITING</span></code> state and another process is running. An interesting
situation occurs when a function that can lead to the current process to be
suspended, is called from an interrupt context. In this case, there is no
current process, and therefore the results are unpredictable. Whenever the
operating system detects this condition will generate an error condition that
will cause the operating system to shut down.</p>
</div>
<div class="section" id="locking">
<h2>Locking<a class="headerlink" href="#locking" title="Permalink to this headline">¶</a></h2>
<p>One of the most important features of kernel programming is parallelism. Linux
supports SMP systems with multiple processors and kernel preemptivity. This
makes kernel programming more difficult because access to global variables must
be synchronized with either spinlock primitives or blocking primitives. Although
it is recommended to use blocking primitives, they can not be used in an
interrupt context, so the only locking solution in the context of an interrupt
is spinlocks.</p>
<p>Spinlocks are used in order to achieve mutual exclusion. When it can not get
access to the critical region, it does not suspend the current process, but it
uses the busy-waiting mechanism (waiting in a <code class="xref c c-func docutils literal"><span class="pre">while()</span></code> loop for the lock
to be released).
The code that runs in the critical region protected by a spinlock is not allowed
to suspend the current process (it must adhere to the execution conditions in
the interrupt context). Moreover, the CPU will not be released except for
the case of an interrupt. Due to the mechanism used, it is important that a
spinlock is being held as little time as possible.</p>
</div>
<div class="section" id="preemptivity">
<h2>Preemptivity<a class="headerlink" href="#preemptivity" title="Permalink to this headline">¶</a></h2>
<p>Linux uses preemptive kernels. The notion of preemptive multitasking should not
be confused with the notion of a preemptive kernel. The notion of preemptive
multitasking refers to the fact that the operating system forcefully interrupts
a process running in user space when its quantum (time slice) expires, in order
to run another process.
A kernel is preemptive if a process running in kernel mode (as a result of a
system call) can be interrupted so that another process is being run.</p>
<p>Because of preemptivity, when we share resources between two portions of code
that can run from different process contexts, we need to protect ourselves with
synchronization primitives, even in the case of a single processor.</p>
</div>
<div class="section" id="linux-kernel-api">
<h2>Linux Kernel API<a class="headerlink" href="#linux-kernel-api" title="Permalink to this headline">¶</a></h2>
<div class="section" id="convention-indicating-errors">
<h3>Convention indicating errors<a class="headerlink" href="#convention-indicating-errors" title="Permalink to this headline">¶</a></h3>
<p>For Linux kernel programming, the convention used for calling functions to
indicate success is the same as in UNIX programming: 0 for success, or a value
other than 0 for failure.
For failures, negative values are returned as shown in the example below:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">alloc_memory</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">user_parameter_valid</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
</pre></div>
</div>
<p>The exhaustive list of errors and a summary explanation can be found in
<code class="file docutils literal"><span class="pre">include/uapi/asm-generic/errno-base.h</span></code> and in
<code class="file docutils literal"><span class="pre">include/uapi/asm-generic/ernno.h</span></code>.</p>
</div>
<div class="section" id="strings-of-characters">
<h3>Strings of characters<a class="headerlink" href="#strings-of-characters" title="Permalink to this headline">¶</a></h3>
<p>In Linux, the kernel programmer is provided with the usual routine functions:
<code class="xref c c-func docutils literal"><span class="pre">strcpy()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">strncpy()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">strlcpy()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">strcat()</span></code>,
<code class="xref c c-func docutils literal"><span class="pre">strncat()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">strlcat()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">strcmp()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">strncmp()</span></code>,
<code class="xref c c-func docutils literal"><span class="pre">strnicmp()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">strchr()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">strnchr()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">strrchr()</span></code>,
<code class="xref c c-func docutils literal"><span class="pre">strstr()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">strlen()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">memset()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">memmove()</span></code>,
<code class="xref c c-func docutils literal"><span class="pre">memcmp()</span></code>, etc. These functions are declared in the
<code class="file docutils literal"><span class="pre">include/linux/string.h</span></code> header and are implemented in the kernel in the
<code class="file docutils literal"><span class="pre">lib/string.c</span></code> file.</p>
</div>
<div class="section" id="printk">
<h3>printk<a class="headerlink" href="#printk" title="Permalink to this headline">¶</a></h3>
<p>The printf equivalent in the kernel is printk, defined in
<code class="file docutils literal"><span class="pre">include/linux/printk.h</span></code>. The <code class="xref c c-func docutils literal"><span class="pre">printk()</span></code> syntax is very similar
to <code class="xref c c-func docutils literal"><span class="pre">printf()</span></code>. The first
parameter of <code class="xref c c-func docutils literal"><span class="pre">printk()</span></code> decides the log category in which the current log
falls into:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#define KERN_EMERG   &quot;&lt;0&gt;&quot;  </span><span class="cm">/* system is unusable */</span><span class="cp"></span>
<span class="cp">#define KERN_ALERT   &quot;&lt;1&gt;&quot;  </span><span class="cm">/* action must be taken immediately */</span><span class="cp"></span>
<span class="cp">#define KERN_CRIT    &quot;&lt;2&gt;&quot;  </span><span class="cm">/* critical conditions */</span><span class="cp"></span>
<span class="cp">#define KERN_ERR     &quot;&lt;3&gt;&quot;  </span><span class="cm">/* error conditions */</span><span class="cp"></span>
<span class="cp">#define KERN_WARNING &quot;&lt;4&gt;&quot;  </span><span class="cm">/* warning conditions */</span><span class="cp"></span>
<span class="cp">#define KERN_NOTICE  &quot;&lt;5&gt;&quot;  </span><span class="cm">/* normal but significant condition */</span><span class="cp"></span>
<span class="cp">#define KERN_INFO    &quot;&lt;6&gt;&quot;  </span><span class="cm">/* informational */</span><span class="cp"></span>
<span class="cp">#define KERN_DEBUG   &quot;&lt;7&gt;&quot;  </span><span class="cm">/* debug-level messages */</span><span class="cp"></span>
</pre></div>
</div>
<p>Thus, a warning message in the kernel would be sent with:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;my_module input string %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buff</span><span class="p">);</span>
</pre></div>
</div>
<p>If the logging level is missing from the <code class="xref c c-func docutils literal"><span class="pre">printk()</span></code> call, logging is done
with the default level at the time of the call. One thing to keep in mind is
that messages sent with <code class="xref c c-func docutils literal"><span class="pre">printk()</span></code> are only visible on the console if and
only if their level exceeds the default level set on the console.</p>
<p>To reduce the size of lines when using <code class="xref c c-func docutils literal"><span class="pre">printk()</span></code>, it is recommended to
use the following help functions instead of directly using the <code class="xref c c-func docutils literal"><span class="pre">printk()</span></code>
call:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">pr_emerg</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span> <span class="cm">/* similar to printk(KERN_EMERG pr_fmt(fmt), ...); */</span>
<span class="n">pr_alert</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span> <span class="cm">/* similar to printk(KERN_ALERT pr_fmt(fmt), ...); */</span>
<span class="n">pr_crit</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span> <span class="cm">/* similar to printk(KERN_CRIT pr_fmt(fmt), ...); */</span>
<span class="n">pr_err</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span> <span class="cm">/* similar to printk(KERN_ERR pr_fmt(fmt), ...); */</span>
<span class="n">pr_warn</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span> <span class="cm">/* similar to printk(KERN_WARNING pr_fmt(fmt), ...); */</span>
<span class="n">pr_notice</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span> <span class="cm">/* similar to printk(KERN_NOTICE pr_fmt(fmt), ...); */</span>
<span class="n">pr_info</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span> <span class="cm">/* similar to printk(KERN_INFO pr_fmt(fmt), ...); */</span>
<span class="n">pr_debug</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span> <span class="cm">/* similar to printk(KERN_DEBUG pr_fmt(fmt), ...); */</span>
</pre></div>
</div>
<p>A special case is <code class="xref c c-func docutils literal"><span class="pre">pr_debug()</span></code> that calls the <code class="xref c c-func docutils literal"><span class="pre">printk()</span></code> function
only when the <code class="xref c c-macro docutils literal"><span class="pre">DEBUG</span></code> macro is defined or if dynamic debugging is used.</p>
</div>
<div class="section" id="memory-allocation">
<h3>Memory allocation<a class="headerlink" href="#memory-allocation" title="Permalink to this headline">¶</a></h3>
<p>In Linux only resident memory can be allocated, using <code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code> call.
A typical <code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code> call is presented below:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/slab.h&gt;</span><span class="cp"></span>

<span class="n">string</span> <span class="o">=</span> <span class="n">kmalloc</span> <span class="p">(</span><span class="n">string_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//report error: -ENOMEM;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As you can see, the first parameter indicates the size in bytes of the allocated
area. The function returns a pointer to a memory area that can be directly used
in the kernel, or <code class="xref c c-macro docutils literal"><span class="pre">NULL</span></code> if memory could not be allocated. The second
parameter specifies how allocation should be done and the most commonly used
values for this are:</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-data docutils literal"><span class="pre">GFP_KERNEL</span></code> - using this value may cause the current process to
be suspended. Thus, it can not be used in the interrupt context.</li>
<li><code class="xref c c-data docutils literal"><span class="pre">GFP_ATOMIC</span></code> - using this value it ensures that the
<code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code> function does not suspend the current process. It can be
used anytime.</li>
</ul>
</div></blockquote>
<p>The counterpart to the <code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code> function is <code class="xref c c-func docutils literal"><span class="pre">kfree()</span></code>, a function
that receives as argument an area allocated by <code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code>. This function
does not suspend the current process and can therefore be called from any
context.</p>
</div>
<div class="section" id="lists">
<h3>lists<a class="headerlink" href="#lists" title="Permalink to this headline">¶</a></h3>
<p>Because linked lists are often used, the Linux kernel API provides a unified
way of defining and using lists. This involves using a
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> element in the structure we want to consider as a
list node. The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> is defined in
<code class="file docutils literal"><span class="pre">include/linux/list.h</span></code> along with all the other functions that manipulate
the lists. The following code shows the definition of
the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> and the use of an element of this type in another
well-known structure in the Linux kernel:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">list_head</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">task_struct</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">children</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The usual routines for working with lists are the following:</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-macro docutils literal"><span class="pre">LIST_HEAD(name)</span></code> is used to declare the sentinel of a list</li>
<li><code class="xref c c-func docutils literal"><span class="pre">INIT_LIST_HEAD(struct</span> <span class="pre">list_head</span> <span class="pre">*list)()</span></code> is used to initialize the
sentinel of a list when dynamic allocation is made, by setting the value of
the <code class="xref c c-data docutils literal"><span class="pre">next</span></code> and <code class="xref c c-data docutils literal"><span class="pre">prev</span></code> to list fields.</li>
<li><code class="xref c c-func docutils literal"><span class="pre">list_add(struct</span> <span class="pre">list_head</span> <span class="pre">*new,</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head)()</span></code> adds the
<code class="xref c c-data docutils literal"><span class="pre">new</span></code> element after the <code class="xref c c-data docutils literal"><span class="pre">head</span></code> element.</li>
<li><code class="xref c c-func docutils literal"><span class="pre">list_del(struct</span> <span class="pre">list_head</span> <span class="pre">*entry)()</span></code> deletes the item at the
<code class="xref c c-data docutils literal"><span class="pre">entry</span></code> address of the list it belongs to.</li>
<li><code class="xref c c-macro docutils literal"><span class="pre">list_entry(ptr,</span> <span class="pre">type,</span> <span class="pre">member)</span></code> returns the structure with the
type <code class="xref c c-type docutils literal"><span class="pre">type</span></code> that contains the element <code class="xref c c-data docutils literal"><span class="pre">ptr</span></code> from the list,
having the name <code class="xref c c-member docutils literal"><span class="pre">member</span></code> within the structure.</li>
<li><code class="xref c c-macro docutils literal"><span class="pre">list_for_each(pos,</span> <span class="pre">head)</span></code> iterates over a list using
<code class="xref c c-data docutils literal"><span class="pre">pos</span></code> as a cursor.</li>
<li><code class="xref c c-macro docutils literal"><span class="pre">list_for_each_safe(pos,</span> <span class="pre">n,</span> <span class="pre">head)</span></code> iterates over a list using
<code class="xref c c-data docutils literal"><span class="pre">pos</span></code> as a cursor and <code class="xref c c-data docutils literal"><span class="pre">n</span></code> as a temporary cursor.
This macro is used to delete an item from the list.</li>
</ul>
</div></blockquote>
<p>The following code shows how to use these routines:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/slab.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/list.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">pid_list</span> <span class="p">{</span>
    <span class="kt">pid_t</span> <span class="n">pid</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">my_list</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">add_pid</span><span class="p">(</span><span class="kt">pid_t</span> <span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">pid_list</span> <span class="o">*</span><span class="n">ple</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">ple</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ple</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

    <span class="n">ple</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">pid</span><span class="p">;</span>
    <span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ple</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_list</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">del_pid</span><span class="p">(</span><span class="kt">pid_t</span> <span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">pid_list</span> <span class="o">*</span><span class="n">ple</span><span class="p">;</span>

    <span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_list</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ple</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pid_list</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ple</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">==</span> <span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">list_del</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="n">kfree</span><span class="p">(</span><span class="n">ple</span><span class="p">);</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">destroy_list</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">pid_list</span> <span class="o">*</span><span class="n">ple</span><span class="p">;</span>

    <span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_list</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ple</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pid_list</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
        <span class="n">list_del</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="n">kfree</span><span class="p">(</span><span class="n">ple</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The evolution of the list can be seen in the following figure:</p>
<a class="reference internal image-reference" href="../_images/list_evolution1.png"><img alt="../_images/list_evolution1.png" src="../_images/list_evolution1.png" style="width: 85%;" /></a>
<p>You see the stack type behavior introduced by the <code class="xref c c-macro docutils literal"><span class="pre">list_add</span></code> macro,
and the use of a sentinel.</p>
<p>From the above example, it can be noticed that the way to define and use a list
(double-linked) is generic and, at the same time, it does not introduce an
additional overhead. The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> is used to maintain the
links between the list elements. It can be noticed that iterating over the list
is also done with this structure, and that retrieving a list element can be done
using <code class="xref c c-macro docutils literal"><span class="pre">list_entry</span></code>. This idea of implementing and using a list is not
new, as it has already been described in The Art of Computer Programming by
Donald Knuth in the 1980s.</p>
<p>Several kernel list functions and macro definitions are presented and explained
in the <code class="file docutils literal"><span class="pre">include/linux/list.h</span></code> header.</p>
</div>
<div class="section" id="spinlock">
<h3>Spinlock<a class="headerlink" href="#spinlock" title="Permalink to this headline">¶</a></h3>
<p><code class="xref c c-type docutils literal"><span class="pre">spinlock_t</span></code> (defined in <code class="file docutils literal"><span class="pre">linux/spinlock.h</span></code>) is the basic type
that implements the spinlock concept in Linux. It describes a spinlock, and the
operations associated with a spinlock are <code class="xref c c-func docutils literal"><span class="pre">spin_lock_init()</span></code>,
<code class="xref c c-func docutils literal"><span class="pre">spin_lock()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">spin_unlock()</span></code>. An example of use is given below:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/spinlock.h&gt;</span><span class="cp"></span>

<span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">lock1</span><span class="p">);</span>
<span class="n">spinlock_t</span> <span class="n">lock2</span><span class="p">;</span>

<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock2</span><span class="p">);</span>

<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock1</span><span class="p">);</span>
<span class="cm">/* critical region */</span>
<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock1</span><span class="p">);</span>

<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock2</span><span class="p">);</span>
<span class="cm">/* critical region */</span>
<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock2</span><span class="p">);</span>
</pre></div>
</div>
<p>In Linux, you can use reader-writer spinlocks, useful for readers-writers
problems.
These types of locks are identified by <code class="xref c c-type docutils literal"><span class="pre">rwlock_t</span></code>, and the functions
that can work on a reader-writer spinlock are
<code class="xref c c-func docutils literal"><span class="pre">rwlock_init()</span></code>,
<code class="xref c c-func docutils literal"><span class="pre">read_lock()</span></code>,
<code class="xref c c-func docutils literal"><span class="pre">write_lock()</span></code>.
An example of use:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/spinlock.h&gt;</span><span class="cp"></span>

<span class="n">DEFINE_RWLOCK</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">pid_list</span> <span class="p">{</span>
    <span class="kt">pid_t</span> <span class="n">pid</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">have_pid</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">lh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">elem</span><span class="p">;</span>

    <span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
    <span class="n">list_for_each</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">lh</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">pid_list</span> <span class="o">*</span><span class="n">pl</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pid_list</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pl</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">==</span> <span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">add_pid</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">lh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pid_list</span> <span class="o">*</span><span class="n">pl</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
    <span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pl</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">lh</span><span class="p">);</span>
    <span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="mutex">
<h3>mutex<a class="headerlink" href="#mutex" title="Permalink to this headline">¶</a></h3>
<p>A mutex is a variable of the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">mutex</span></code> type (defined in
<code class="file docutils literal"><span class="pre">linux/mutex.h</span></code>).
Functions and macros for working with mutexes are listed below:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/mutex.h&gt;</span><span class="cp"></span>

<span class="cm">/* functions for mutex initialization */</span>
<span class="kt">void</span> <span class="nf">mutex_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">mutex</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
<span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>

<span class="cm">/* functions for mutex acquire */</span>
<span class="kt">void</span> <span class="nf">mutex_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">mutex</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>

<span class="cm">/* functions for mutex release */</span>
<span class="kt">void</span> <span class="nf">mutex_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">mutex</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
</pre></div>
</div>
<p>Operations are similar to classic mutex operations in user-space or spinlock
operations: the mutex is acquired before entering the critical region and it is
released after exiting the critical region. Unlike spinlocks, these operations
can only be used in process context.</p>
</div>
<div class="section" id="atomic-variables-1">
<span id="atomic-variables"></span><h3>Atomic variables<a class="headerlink" href="#atomic-variables-1" title="Permalink to this headline">¶</a></h3>
<p>Often, you only need to synchronize access to a simple variable, such as a
counter. For this, an <code class="xref c c-type docutils literal"><span class="pre">atomic_t</span></code> type can be used (defined in
<code class="file docutils literal"><span class="pre">include/linux/atomic.h</span></code>), that holds an integer value. Below are some
operations that can be performed on an <code class="xref c c-type docutils literal"><span class="pre">atomic_t</span></code> variable.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;asm/atomic.h&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">atomic_set</span><span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">atomic_read</span><span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">atomic_add</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">atomic_sub</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">atomic_inc</span><span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">atomic_dec</span><span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">atomic_inc_and_test</span><span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">atomic_dec_and_test</span><span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">atomic_cmpxchg</span><span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">old</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new</span><span class="p">);</span>
</pre></div>
</div>
<div class="section" id="use-of-atomic-variables">
<h4>Use of atomic variables<a class="headerlink" href="#use-of-atomic-variables" title="Permalink to this headline">¶</a></h4>
<p>A common way of using atomic variables is to store the status of an action
(e.g. a flag). So we can use an atomic variable to mark exclusive actions. For
example, we consider that an atomic variable can have the LOCKED and UNLOCKED
values, and if the respective variable equals LOCKED then a specific function
should return -EBUSY.
Such an usage is shown schematically in the code below:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#define LOCKED       0</span>
<span class="cp">#define UNLOCKED     1</span>

<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">flag</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_acquire</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
     <span class="kt">int</span> <span class="n">initial_flag</span><span class="p">;</span>

     <span class="cm">/*</span>
<span class="cm">      * Check if flag is UNLOCKED; if so, lock it and do it atomically.</span>
<span class="cm">      *</span>
<span class="cm">      * This is the atomic equivalent of</span>
<span class="cm">      *      if (flag == UNLOCKED)</span>
<span class="cm">      *              flag = LOCKED;</span>
<span class="cm">      *      else</span>
<span class="cm">      *              return -EBUSY;</span>
<span class="cm">      */</span>
     <span class="n">initial_flag</span> <span class="o">=</span> <span class="n">atomic_cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flag</span><span class="p">,</span> <span class="n">UNLOCKED</span><span class="p">,</span> <span class="n">LOCKED</span><span class="p">);</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">initial_flag</span> <span class="o">==</span> <span class="n">LOCKED</span><span class="p">)</span> <span class="p">{</span>
             <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;Already locked.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
             <span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
     <span class="p">}</span>

     <span class="cm">/* Do your thing after getting the lock. */</span>
     <span class="p">[...]</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">my_release</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
     <span class="cm">/* Release flag; mark it as unlocked. */</span>
     <span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flag</span><span class="p">,</span> <span class="n">UNLOCKED</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">my_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
     <span class="p">[...]</span>
     <span class="cm">/* Atomic variable is initially unlocked. */</span>
     <span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flag</span><span class="p">,</span> <span class="n">UNLOCKED</span><span class="p">);</span>

     <span class="p">[...]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The above code is the equivalent of using a trylock (such as
<code class="xref c c-func docutils literal"><span class="pre">pthread_mutex_trylock()</span></code>).</p>
<p>We can also use a variable to store the size of a buffer and for atomic
updates of the respective variable. The code below is such an example:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">MAX_SIZE</span><span class="p">];</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">size</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_to_buffer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
     <span class="n">buffer</span><span class="p">[</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">size</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
     <span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">remove_from_buffer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
     <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">value</span><span class="p">;</span>

     <span class="n">value</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">size</span><span class="p">)];</span>
     <span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>

     <span class="k">return</span> <span class="n">value</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">reset_buffer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
     <span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">my_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
     <span class="p">[...]</span>
     <span class="cm">/* Initialized buffer and size. */</span>
     <span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
     <span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>

     <span class="p">[...]</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="atomic-bitwise-operations">
<h3>Atomic bitwise operations<a class="headerlink" href="#atomic-bitwise-operations" title="Permalink to this headline">¶</a></h3>
<p>The kernel provides a set of functions (in <code class="file docutils literal"><span class="pre">asm/bitops.h</span></code>) that modify or
test bits in an atomic way.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;asm/bitops.h&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">set_bit</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">clear_bit</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">change_bit</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">test_and_set_bit</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">test_and_clear_bit</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">test_and_change_bit</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="xref c c-data docutils literal"><span class="pre">Addr</span></code> represents the address of the memory area whose bits are being
modified or tested and <code class="xref c c-data docutils literal"><span class="pre">nr</span></code> is the bit on which the operation is
performed.</p>
</div>
</div>
<div class="section" id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p>To solve exercises, you need to perform these steps:</p>
<blockquote>
<div><ul class="simple">
<li>prepare skeletons from templates</li>
<li>build modules</li>
<li>copy modules to the VM</li>
<li>start the VM and test the module in the VM.</li>
</ul>
</div></blockquote>
<p>The current lab name is kernel_api. See the exercises for the task name.</p>
<p>The skeleton code is generated from full source examples located in
<code class="file docutils literal"><span class="pre">tools/labs/templates</span></code>. To solve the tasks, start by generating
the skeleton code for a complete lab:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make clean
tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt; make skels
</pre></div>
</div>
<p>You can also generate the skeleton for a single task, using</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt;/&lt;task name&gt; make skels
</pre></div>
</div>
<p>Once the skeleton drivers are generated, build the source:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make build
</pre></div>
</div>
<p>Then, copy the modules and start the VM:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make copy
tools/labs $ make boot
</pre></div>
</div>
<p>The modules are placed in /home/root/skels/kernel_api/&lt;task_name&gt;.</p>
<p>Alternatively, we can copy files via <strong class="command">scp</strong>, in order to avoid restarting the VM.
For additional details about connecting to the VM via the network, please check <a class="reference internal" href="../info/vm.html#vm-interaction-link"><span class="std std-ref">Connecting to the Virtual Machine</span></a>.</p>
<p class="last">Review the <a class="reference internal" href="#exercises">Exercises</a> section for more detailed information.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>Before starting the exercises or generating the skeletons, please run <strong>git pull</strong> inside the Linux repo,
to make sure you have the latest version of the exercises.</p>
<p>If you have local changes, the pull command will fail. Check for local changes using <code class="docutils literal"><span class="pre">git</span> <span class="pre">status</span></code>.
If you want to keep them, run <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span></code> before <code class="docutils literal"><span class="pre">pull</span></code> and <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span> <span class="pre">pop</span></code> after.
To discard the changes, run <code class="docutils literal"><span class="pre">git</span> <span class="pre">reset</span> <span class="pre">--hard</span> <span class="pre">master</span></code>.</p>
<p class="last">If you already generated the skeleton before <code class="docutils literal"><span class="pre">git</span> <span class="pre">pull</span></code> you will need to generate it again.</p>
</div>
<div class="section" id="intro">
<h3>0. Intro<a class="headerlink" href="#intro" title="Permalink to this headline">¶</a></h3>
<p>Using <a class="reference external" href="http://elixir.free-electrons.com/linux/latest/source">LXR</a> find the definitions of the following symbols in the Linux kernel:</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">INIT_LIST_HEAD()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">list_add()</span></code></li>
<li><code class="xref c c-macro docutils literal"><span class="pre">list_for_each</span></code></li>
<li><code class="xref c c-macro docutils literal"><span class="pre">list_entry</span></code></li>
<li><code class="xref c c-macro docutils literal"><span class="pre">container_of</span></code></li>
<li><code class="xref c c-macro docutils literal"><span class="pre">offsetof</span></code></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="memory-allocation-in-linux-kernel">
<h3>1. Memory allocation in Linux kernel<a class="headerlink" href="#memory-allocation-in-linux-kernel" title="Permalink to this headline">¶</a></h3>
<p>Generate the skeleton for the task named <strong>1-mem</strong> and browse the
contents of the <code class="file docutils literal"><span class="pre">mem.c</span></code> file.  Observe the use of <code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code>
call for memory allocation.</p>
<blockquote>
<div><ol class="arabic simple">
<li>Compile the source code and load the <code class="file docutils literal"><span class="pre">mem.ko</span></code> module using
<strong class="command">insmod</strong>.</li>
<li>View the kernel messages using the <strong class="command">dmesg</strong> command.</li>
<li>Unload the kernel module using the <strong class="command">rmmod mem</strong> command.</li>
</ol>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Review the <a class="reference internal" href="#memory-allocation">Memory Allocation</a> section in the lab.</p>
</div>
</div>
<div class="section" id="sleeping-in-atomic-context">
<h3>2. Sleeping in atomic context<a class="headerlink" href="#sleeping-in-atomic-context" title="Permalink to this headline">¶</a></h3>
<p>Generate the skeleton for the task named <strong>2-sched-spin</strong> and browse
the contents of the <code class="file docutils literal"><span class="pre">sched-spin.c</span></code> file.</p>
<blockquote>
<div><ol class="arabic simple">
<li>Compile the source code and load the module, according the above info:
(<strong class="command">make build</strong> and <strong class="command">make copy</strong>)</li>
<li>Notice that it is waiting for 5 seconds until the insertion
order is complete.</li>
<li>Unload the kernel module.</li>
<li>Look for the lines marked with: <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">0</span></code> to create an atomic
section. Re-compile the source code and reload the module into
the kernel.</li>
</ol>
</div></blockquote>
<p>You should now get an error. Look at the stack trace. What is the
cause of the error?</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">In the error message, follow the line containing the <code class="xref c c-macro docutils literal"><span class="pre">BUG</span></code>
for a description of the error. You are not allowed to sleep in
atomic context.  The atomic context is given by a section
between a lock operation and an unlock on a spinlock.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The
<code class="xref c c-func docutils literal"><span class="pre">schedule_timeout()</span></code> function, corroborated with the
<code class="xref c c-macro docutils literal"><span class="pre">set_current_state</span></code> macro, forces the current process to wait
for 5 seconds.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Review the <a class="reference internal" href="#contexts-of-execution">Contexts of execution</a>, <a class="reference internal" href="#locking">Locking</a> and <a class="reference internal" href="#spinlock">Spinlock</a>
sections.</p>
</div>
</div>
<div class="section" id="working-with-kernel-memory">
<h3>3. Working with kernel memory<a class="headerlink" href="#working-with-kernel-memory" title="Permalink to this headline">¶</a></h3>
<p>Generate the skeleton for the task named <strong>3-memory</strong> directory and
browse the contents of the <code class="file docutils literal"><span class="pre">memory.c</span></code> file. Notice the comments
marked with <code class="docutils literal"><span class="pre">TODO</span></code>. You must allocate 4 structures of type <code class="xref c c-type docutils literal"><span class="pre">struct</span>
<span class="pre">task_info</span></code> and initialize them (in <code class="xref c c-func docutils literal"><span class="pre">memory_init()</span></code>), then print and
free them (in <code class="xref c c-func docutils literal"><span class="pre">memory_exit()</span></code>).</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">(TODO 1) Allocate memory for <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_info</span></code> structure and
initialize its fields:</p>
<ul class="simple">
<li>The <code class="xref c c-member docutils literal"><span class="pre">pid</span></code> field to the PID transmitted as a parameter;</li>
<li>The <code class="xref c c-member docutils literal"><span class="pre">timestamp</span></code> field to the value of the <code class="xref c c-data docutils literal"><span class="pre">jiffies</span></code>
variable, which holds the number of ticks that have occurred since the
system booted.</li>
</ul>
</li>
<li><p class="first">(TODO 2) Allocate <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_info</span></code> for the current process,
the parent process, the next process, the next process of the next
process, with the following information:</p>
<ul class="simple">
<li>PID of the current process, which can be retrieved from
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code> structure, returned by <code class="xref c c-macro docutils literal"><span class="pre">current</span></code>
macro.</li>
</ul>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">Search for <code class="xref c c-type docutils literal"><span class="pre">pid</span></code> in <code class="xref c c-type docutils literal"><span class="pre">task_struct</span></code>.</p>
</div>
<ul class="simple">
<li>PID of the parent process of the current process.</li>
</ul>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">Search for the relevant field from <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code>
structure. Look after &quot;parent&quot;.</p>
</div>
<ul class="simple">
<li>PID of the next process from the list of processes, relative to the
current process.</li>
</ul>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">Use <code class="xref c c-macro docutils literal"><span class="pre">next_task</span></code> macro, which returns a pointer to the next
process (i.e a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code> structure).</p>
</div>
<ul class="simple">
<li>PID of the next process of the next process, relative to the current
process.</li>
</ul>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">Call the <code class="xref c c-macro docutils literal"><span class="pre">next_task</span></code> macro 2 times.</p>
</div>
</li>
<li><p class="first">(TODO 3) Display the four structures.</p>
<ul class="simple">
<li>Use <code class="xref c c-func docutils literal"><span class="pre">printk()</span></code> to display their two fields:</li>
</ul>
<p><code class="xref c c-member docutils literal"><span class="pre">pid</span></code> and <code class="xref c c-member docutils literal"><span class="pre">timestamp</span></code>.</p>
</li>
<li><p class="first">(TODO 4) Release the memory occupied by the structures
(use <code class="xref c c-func docutils literal"><span class="pre">kfree()</span></code>).</p>
</li>
</ol>
</div></blockquote>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<ul class="last simple">
<li>You can access the current process using <code class="xref c c-macro docutils literal"><span class="pre">current</span></code>
macro.</li>
<li>Look for the relevant fields in the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code>
structure (<code class="xref c c-member docutils literal"><span class="pre">pid</span></code>, <code class="xref c c-member docutils literal"><span class="pre">parent</span></code>).</li>
<li>Use the <code class="xref c c-macro docutils literal"><span class="pre">next_task</span></code> macro. The macro returns the pointer to
the next process (ie. a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct*</span></code> structure).</li>
</ul>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code> structure contains two fields to
designate the parent of a task:</p>
<ul class="simple">
<li><code class="xref c c-member docutils literal"><span class="pre">real_parent</span></code> points to the process that created the
task or to process with pid 1 (init) if the parent
completed its execution.</li>
<li><code class="xref c c-member docutils literal"><span class="pre">parent</span></code> indicates to the current task parent (the
process that will be reported if the task completes
execution).</li>
</ul>
<p class="last">In general, the values of the two fields are the same, but
there are situations where they differ, for example when
using the <code class="xref c c-func docutils literal"><span class="pre">ptrace()</span></code> system call.</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">Review the <a class="reference internal" href="#memory-allocation">Memory allocation</a> section in the lab.</p>
</div>
</div>
<div class="section" id="working-with-kernel-lists">
<h3>4. Working with kernel lists<a class="headerlink" href="#working-with-kernel-lists" title="Permalink to this headline">¶</a></h3>
<p>Generate the skeleton for the task named <strong>4-list</strong>. Browse the
contents of the <code class="file docutils literal"><span class="pre">list.c</span></code> file and notice the comments marked with
<code class="docutils literal"><span class="pre">TODO</span></code>. The current process will add the four structures from the
previous exercise into a list. The list will be built in the
<code class="xref c c-func docutils literal"><span class="pre">task_info_add_for_current()</span></code> function which is called when module is
loaded. The list will be printed and deleted in the <code class="xref c c-func docutils literal"><span class="pre">list_exit()</span></code>
function and the <code class="xref c c-func docutils literal"><span class="pre">task_info_purge_list()</span></code> function.</p>
<blockquote>
<div><ol class="arabic simple">
<li>(TODO 1) Complete the <code class="xref c c-func docutils literal"><span class="pre">task_info_add_to_list()</span></code> function to allocate
a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_info</span></code> structure and add it to the list.</li>
<li>(TODO 2) Complete the <code class="xref c c-func docutils literal"><span class="pre">task_info_purge_list()</span></code> function to delete
all the elements in the list.</li>
<li>Compile the kernel module. Load and unload the module by
following the messages displayed by the kernel.</li>
</ol>
</div></blockquote>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">Review the labs <a class="reference internal" href="#lists">Lists</a> section.  When deleting items from
the list, you will need to use either the
<code class="xref c c-macro docutils literal"><span class="pre">list_for_each_safe</span></code> or <code class="xref c c-macro docutils literal"><span class="pre">list_for_each_entry_safe</span></code>
macros.</p>
</div>
</div>
<div class="section" id="working-with-kernel-lists-for-process-handling">
<h3>5. Working with kernel lists for process handling<a class="headerlink" href="#working-with-kernel-lists-for-process-handling" title="Permalink to this headline">¶</a></h3>
<p>Generate the skeleton for the task named <strong>5-list-full</strong>. Browse the
contents of the <code class="file docutils literal"><span class="pre">list-full.c</span></code> and notice comments marked with
<code class="docutils literal"><span class="pre">TODO</span></code>. In addition to the <code class="file docutils literal"><span class="pre">4-list</span></code> functionality we add the
following:</p>
<blockquote>
<div><ul>
<li><p class="first">A <code class="xref c c-member docutils literal"><span class="pre">count</span></code> field showing how many times a process has been &quot;added&quot;
to the list.</p>
</li>
<li><p class="first">If a process is &quot;added&quot; several times, no new entry is created in
the list, but:</p>
<blockquote>
<div><ul class="simple">
<li>Update the <code class="xref c c-member docutils literal"><span class="pre">timestamp</span></code> field.</li>
<li>Increment <code class="xref c c-member docutils literal"><span class="pre">count</span></code>.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">To implement the counter facility, add a <code class="xref c c-func docutils literal"><span class="pre">task_info_find_pid()</span></code>
function that searches for a pid in the existing list.</p>
</li>
<li><p class="first">If found, return the reference to the <code class="xref c c-type docutils literal"><span class="pre">task_info</span></code> struct. If
not, return <code class="xref c c-macro docutils literal"><span class="pre">NULL</span></code>.</p>
</li>
<li><p class="first">An expiration facility. If a process was added more than 3
seconds ago and if it does not have a <code class="xref c c-member docutils literal"><span class="pre">count</span></code> greater than 5 then
it is considered expired and is removed from the list.</p>
</li>
<li><p class="first">The expiration facility is already implemented in the
<code class="xref c c-func docutils literal"><span class="pre">task_info_remove_expired()</span></code> function.</p>
</li>
</ul>
<ol class="arabic">
<li><p class="first">(TODO 1) Implement the <code class="xref c c-func docutils literal"><span class="pre">task_info_find_pid()</span></code> function.</p>
</li>
<li><p class="first">(TODO 2) Change a field of an item in the list so it does not
expire. It must not satisfy a part of the expiration condition
from <code class="xref c c-func docutils literal"><span class="pre">task_info_remove_expired()</span></code>.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">For <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">2</span></code>, extract the first element from the list (the one
referred by <code class="xref c c-member docutils literal"><span class="pre">head.next</span></code>) and set the <code class="xref c c-member docutils literal"><span class="pre">count</span></code>
field to a large enough value. Use <code class="xref c c-func docutils literal"><span class="pre">atomic_set()</span></code> function.</p>
</div>
</li>
<li><p class="first">Compile, copy, load and unload the kernel module following the displayed
messages.
Kernel module loading will take some time, because <code class="xref c c-func docutils literal"><span class="pre">sleep()</span></code> is
being called by <code class="xref c c-func docutils literal"><span class="pre">schedule_timeout()</span></code> function.</p>
</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="synchronizing-list-work">
<h3>6. Synchronizing list work<a class="headerlink" href="#synchronizing-list-work" title="Permalink to this headline">¶</a></h3>
<p>Generate the skeleton for the task named <strong>6-list-sync</strong>.</p>
<blockquote>
<div><ol class="arabic simple">
<li>Browse the code and look for <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">1</span></code> string.</li>
<li>Use a spinlock or a read-write lock to synchronize access to the
list.</li>
<li>Compile, load and unload the kernel module.</li>
</ol>
</div></blockquote>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">Always lock data, not code!</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Read <a class="reference internal" href="#spinlock">Spinlock</a> section of the lab.</p>
</div>
</div>
<div class="section" id="test-module-calling-in-our-list-module">
<h3>7. Test module calling in our list module<a class="headerlink" href="#test-module-calling-in-our-list-module" title="Permalink to this headline">¶</a></h3>
<p>Generate the skeleton for the task named <strong>7-list-test</strong> and browse
the contents of the <code class="file docutils literal"><span class="pre">list-test.c</span></code> file. We'll use it as a test
module. It will call functions exported by the <strong>6-list-sync</strong>
task. The exported functions are the ones marked with <strong>extern</strong> in
<code class="file docutils literal"><span class="pre">list-test.c</span></code> file.</p>
<p>Uncomment the commented code from <code class="file docutils literal"><span class="pre">7-list-test.c</span></code>. Look for <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">1</span></code>.</p>
<p>To export the above functions from the module located at <code class="file docutils literal"><span class="pre">6-list-sync/</span></code>
directory, the following steps are required:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Functions must not be static.</li>
<li>Use the <code class="xref c c-macro docutils literal"><span class="pre">EXPORT_SYMBOL</span></code> macro to export the kernel symbols. For
example: <code class="xref c c-macro docutils literal"><span class="pre">EXPORT_SYMBOL(task_info_remove_expired);</span></code>. The
macro must be used for each function after the function is defined.
Browse the code and look for the <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">2</span></code> string in the
<code class="file docutils literal"><span class="pre">list-sync.c</span></code>.</li>
<li>Remove from the module from <strong>6-list-sync</strong> the code that avoids the
expiration of a list item (it is in contradiction to our exercise).</li>
<li>Compile and load the module from <code class="file docutils literal"><span class="pre">6-list-sync/</span></code>. Once loaded, it
exposes exported functions and can be used by the test
module. You can check this by searching for the function names
in <code class="file docutils literal"><span class="pre">/proc/kallsyms</span></code> before and after loading the module.</li>
<li>Compile the test module and then load it.</li>
<li>Use <strong class="command">lsmod</strong> to check that the two modules have been loaded.
What do you notice?</li>
<li>Unload the kernel test module.</li>
</ol>
</div></blockquote>
<p>What should be the unload order of the two modules (the module from
<strong>6-list-sync</strong> and the test module)? What happens if you use another order?</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="lab1-intro.html" class="btn btn-neutral float-left" title="SO2 Lab 01 - Introduction" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="lab3-device-drivers.html" class="btn btn-neutral float-right" title="SO2 Lab 03 - Character device drivers" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright The kernel development community.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>