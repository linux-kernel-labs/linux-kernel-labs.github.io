

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Block Device Drivers &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/asciinema-player.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Memory mapping" href="memory_mapping.html" />
    <link rel="prev" title="Deferred work" href="deferred_work.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.15.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../lectures/so2.cs.pub.ro.html">Sisteme de operare 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/syscalls.html">System Calls</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/interrupts.html">Interrupts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/smp.html">Symmetric Multi-Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/debugging.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="vm.html">Virtual Machine Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="exercises.html">Exercises</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="kernel_modules.html">Kernel modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="kernel_api.html">Kernel API</a></li>
<li class="toctree-l1"><a class="reference internal" href="device_drivers.html">Character device drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="interrupts.html">I/O access and Interrupts</a></li>
<li class="toctree-l1"><a class="reference internal" href="deferred_work.html">Deferred work</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Block Device Drivers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#lab-objectives">Lab objectives</a></li>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#register-a-block-i-o-device">Register a block I/O device</a></li>
<li class="toctree-l2"><a class="reference internal" href="#register-a-disk">Register a disk</a></li>
<li class="toctree-l2"><a class="reference internal" href="#struct-gendisk-structure"><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span></code> structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="#struct-block-device-operations-structure"><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device_operations</span></code> structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="#request-queues">Request queues</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#create-and-delete-a-request-queue">Create and delete a request queue</a></li>
<li class="toctree-l3"><a class="reference internal" href="#useful-functions-for-processing-request-queues">Useful functions for processing request queues</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#requests-for-block-devices">Requests for block devices</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#create-a-request">Create a request</a></li>
<li class="toctree-l3"><a class="reference internal" href="#finish-a-request">Finish a request</a></li>
<li class="toctree-l3"><a class="reference internal" href="#process-a-request">Process a request</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#struct-bio-structure"><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#create-a-struct-bio-structure">Create a <code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#submit-a-struct-bio-structure">Submit a <code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#wait-for-the-completion-of-a-struct-bio-structure">Wait for the completion of a <code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#initialize-a-struct-bio-structure">Initialize a <code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#how-to-use-the-content-of-a-struct-bio-structure">How to use the content of a <code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#free-a-struct-bio-structure">Free a <code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#set-up-a-request-queue-at-struct-bio-level">Set up a request queue at <code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> level</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#further-reading">Further reading</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exercises">Exercises</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#intro">0. Intro</a></li>
<li class="toctree-l3"><a class="reference internal" href="#block-device">1. Block device</a></li>
<li class="toctree-l3"><a class="reference internal" href="#disk-registration">2. Disk registration</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ram-disk">3. RAM disk</a></li>
<li class="toctree-l3"><a class="reference internal" href="#read-data-from-the-disk">4. Read data from the disk</a></li>
<li class="toctree-l3"><a class="reference internal" href="#write-data-to-the-disk">5. Write data to the disk</a></li>
<li class="toctree-l3"><a class="reference internal" href="#processing-requests-from-the-request-queue-at-struct-bio-level">6. Processing requests from the request queue at <code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> level</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="memory_mapping.html">Memory mapping</a></li>
<li class="toctree-l1"><a class="reference internal" href="device_model.html">Linux Device Model</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Block Device Drivers</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/labs/block_device_drivers.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="block-device-drivers">
<h1>Block Device Drivers<a class="headerlink" href="#block-device-drivers" title="Permalink to this headline">¶</a></h1>
<div class="section" id="lab-objectives">
<h2>Lab objectives<a class="headerlink" href="#lab-objectives" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li>acquiring knowledge about the behavior of the I/O subsystem on Linux</li>
<li>hands-on activities in structures and functions of block devices</li>
<li>acquiring basic skills for utilizing the API for block devices, by solving
exercises</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>Block devices are characterized by random access to data organized in fixed-size
blocks. Examples of such devices are hard drives, CD-ROM drives, RAM disks, etc.
The speed of block devices is generally much higher than the speed of character
devices, and their performance is also important. This is why the Linux kernel
handles differently these 2 types of devices (it uses a specialized API).</p>
<p>Working with block devices is therefore more complicated than working with
character devices. Character devices have a single current position, while block
devices must be able to move to any position in the device to provide random
access to data. To simplify work with block devices, the Linux kernel provides
an entire subsystem called the block I/O (or block layer) subsystem.</p>
<p>From the kernel perspective, the smallest logical unit of addressing is the
block. Although the physical device can be addressed at sector level, the kernel
performs all disk operations using blocks. Since the smallest unit of physical
addressing is the sector, the size of the block must be a multiple of the size
of the sector. Additionally, the block size must be a power of 2 and can not
exceed the size of a page. The size of the block may vary depending on the file
system used, the most common values being 512 bytes, 1 kilobytes and 4
kilobytes.</p>
</div>
<div class="section" id="register-a-block-i-o-device">
<h2>Register a block I/O device<a class="headerlink" href="#register-a-block-i-o-device" title="Permalink to this headline">¶</a></h2>
<p>To register a block I/O device, function <code class="xref c c-func docutils literal"><span class="pre">register_blkdev()</span></code> is used.
To deregister a block I/O device, function <code class="xref c c-func docutils literal"><span class="pre">unregister_blkdev()</span></code> is
used.</p>
<p>Starting with version 4.9 of the Linux kernel, the call to
<code class="xref c c-func docutils literal"><span class="pre">register_blkdev()</span></code> is optional. The only operations performed by this
function are the dynamic allocation of a major (if the major argument is 0 when
calling the function) and creating an entry in <code class="file docutils literal"><span class="pre">/proc/devices</span></code>. In
future kernel versions it may be removed; however, most drivers still call it.</p>
<p>Usually, the call to the register function is performed in the module
initialization function, and the call to the deregister function is performed in
the module exit function. A typical scenario is presented below:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp"></span>

<span class="cp">#define MY_BLOCK_MAJOR           240</span>
<span class="cp">#define MY_BLKDEV_NAME          &quot;mybdev&quot;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_block_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

    <span class="n">status</span> <span class="o">=</span> <span class="n">register_blkdev</span><span class="p">(</span><span class="n">MY_BLOCK_MAJOR</span><span class="p">,</span> <span class="n">MY_BLKDEV_NAME</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
             <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;unable to register mybdev block device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
             <span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
     <span class="p">}</span>
     <span class="c1">//...</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">my_block_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
     <span class="c1">//...</span>
     <span class="n">unregister_blkdev</span><span class="p">(</span><span class="n">MY_BLOCK_MAJOR</span><span class="p">,</span> <span class="n">MY_BLKDEV_NAME</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="register-a-disk">
<h2>Register a disk<a class="headerlink" href="#register-a-disk" title="Permalink to this headline">¶</a></h2>
<p>Although the <code class="xref c c-func docutils literal"><span class="pre">register_blkdev()</span></code> function obtains a major, it does not
provide a device (disk) to the system. For creating and using block devices
(disks), a specialized interface defined in <code class="file docutils literal"><span class="pre">linux/genhd.h</span></code> is used.</p>
<p>The useful functions defined in <code class="file docutils literal"><span class="pre">linux/genhd.h</span></code> are to register /allocate
a disk, add it to the system, and de-register /unmount the disk.</p>
<p>The <code class="xref c c-func docutils literal"><span class="pre">alloc_disk()</span></code> function is used to allocate a disk, and the
<code class="xref c c-func docutils literal"><span class="pre">del_gendisk()</span></code> function is used to deallocate it. Adding the disk to the
system is done using the <code class="xref c c-func docutils literal"><span class="pre">add_disk()</span></code> function.</p>
<p>The <code class="xref c c-func docutils literal"><span class="pre">alloc_disk()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">add_disk()</span></code> functions are typically used in
the module initialization function, and the <code class="xref c c-func docutils literal"><span class="pre">del_gendisk()</span></code> function in
the module exit function.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/genhd.h&gt;</span><span class="cp"></span>

<span class="cp">#define MY_BLOCK_MINORS       1</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">my_block_dev</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">gd</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="p">}</span> <span class="n">dev</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_block_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_block_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span> <span class="o">=</span> <span class="n">alloc_disk</span><span class="p">(</span><span class="n">MY_BLOCK_MINORS</span><span class="p">);</span>
    <span class="c1">//...</span>
    <span class="n">add_disk</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_block_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//...</span>
    <span class="n">create_block_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">delete_block_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_block_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="p">)</span>
        <span class="n">del_gendisk</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="p">);</span>
    <span class="c1">//...</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">my_block_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">delete_block_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">);</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As with character devices, it is recommended to use <code class="xref c c-type docutils literal"><span class="pre">my_block_dev</span></code>
structure to store important elements describing the block device.</p>
<p>Note that immediately after calling the <code class="xref c c-func docutils literal"><span class="pre">add_disk()</span></code> function (actually
even during the call), the disk is active and its methods can be called at any
time. As a result, this function should not be called before the driver is fully
initialized and ready to respond to requests for the registered disk.</p>
<p>It can be noticed that the basic structure in working with block devices (disks)
is the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span></code> structure.</p>
<p>After a call to <code class="xref c c-func docutils literal"><span class="pre">del_gendisk()</span></code>, the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span></code> structure
may continue to exist (and the device operations may still be called) if there
are still users (an open operation was called on the device but the associated
release operation has not been called). One solution is to keep the number of
users of the device and call the <code class="xref c c-func docutils literal"><span class="pre">del_gendisk()</span></code> function only when there
are no users left of the device.</p>
</div>
<div class="section" id="struct-gendisk-structure">
<h2><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span></code> structure<a class="headerlink" href="#struct-gendisk-structure" title="Permalink to this headline">¶</a></h2>
<p>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span></code> structure stores information about a disk. As
stated above, such a structure is obtained from the <code class="xref c c-func docutils literal"><span class="pre">alloc_disk()</span></code> call
and must be completed before it is sent to the <code class="xref c c-func docutils literal"><span class="pre">add_disk()</span></code> function.</p>
<p>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span></code> structure has the following important fields:</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-member docutils literal"><span class="pre">major</span></code>, <code class="xref c c-member docutils literal"><span class="pre">first_minor</span></code>, <code class="xref c c-member docutils literal"><span class="pre">minor</span></code>, describing
the identifiers used by the disk; a disk must have at least one minor; if
the disk allows the partitioning operation, a minor must be allocated for
each possible partition</li>
<li><code class="xref c c-member docutils literal"><span class="pre">disk_name</span></code>, which represents the disk name as it appears in
<code class="file docutils literal"><span class="pre">/proc/partitions</span></code> and in sysfs (<code class="file docutils literal"><span class="pre">/sys/block</span></code>)</li>
<li><code class="xref c c-member docutils literal"><span class="pre">fops</span></code>, representing operations associated with the disk</li>
<li><code class="xref c c-member docutils literal"><span class="pre">queue</span></code>, which represents the queue of requests</li>
<li><code class="xref c c-member docutils literal"><span class="pre">capacity</span></code>, which is disk capacity in 512 byte sectors;
it is initialized using the <code class="xref c c-func docutils literal"><span class="pre">set_capacity()</span></code> function</li>
<li><code class="xref c c-member docutils literal"><span class="pre">private_data</span></code>, which is a pointer to private data</li>
</ul>
</div></blockquote>
<p>An example of filling a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span></code> structure is presented below:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/genhd.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/blkdev.h&gt;</span><span class="cp"></span>

<span class="cp">#define NR_SECTORS                   1024</span>

<span class="cp">#define KERNEL_SECTOR_SIZE           512</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">my_block_dev</span> <span class="p">{</span>
    <span class="c1">//...</span>
    <span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>                <span class="cm">/* For mutual exclusion */</span>
    <span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>    <span class="cm">/* The device request queue */</span>
    <span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">gd</span><span class="p">;</span>             <span class="cm">/* The gendisk structure */</span>
    <span class="c1">//...</span>
<span class="p">}</span> <span class="n">dev</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_block_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_block_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="cm">/* Initialize the gendisk structure */</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span> <span class="o">=</span> <span class="n">alloc_disk</span><span class="p">(</span><span class="n">MY_BLOCK_MINORS</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printk</span> <span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;alloc_disk failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="o">-&gt;</span><span class="n">major</span> <span class="o">=</span> <span class="n">MY_BLOCK_MAJOR</span><span class="p">;</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="o">-&gt;</span><span class="n">first_minor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="o">-&gt;</span><span class="n">fops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_block_ops</span><span class="p">;</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">;</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
    <span class="n">snprintf</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="s">&quot;myblock&quot;</span><span class="p">);</span>
    <span class="n">set_capacity</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="p">,</span> <span class="n">NR_SECTORS</span><span class="p">);</span>

    <span class="n">add_disk</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_block_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
    <span class="c1">//...</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">create_block_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">status</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">delete_block_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_block_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">del_gendisk</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">//...</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">my_block_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">delete_block_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">);</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As stated before, the kernel considers a disk as a vector of 512 byte sectors.
In reality, the devices may have a different size of the sector. To work with
these devices, the kernel needs to be informed about the real size of a sector,
and for all operations the necessary conversions must be made.</p>
<p>To inform the kernel about the device sector size, a parameter of the request
queue must be set just after the request queue is allocated, using the
<code class="xref c c-func docutils literal"><span class="pre">blk_queue_logical_block_size()</span></code> function. All requests generated by the
kernel will be multiple of this sector size and will be aligned accordingly.
However, communication between the device and the driver will still be performed
in sectors of 512 bytes in size, so conversion should be done each time (an
example of such conversion is when calling the <code class="xref c c-func docutils literal"><span class="pre">set_capacity()</span></code> function
in the code above).</p>
</div>
<div class="section" id="struct-block-device-operations-structure">
<h2><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">block_device_operations</span></code> structure<a class="headerlink" href="#struct-block-device-operations-structure" title="Permalink to this headline">¶</a></h2>
<p>Just as for a character device, operations in <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file_operations</span></code>
should be completed, so for a block device, the operations in
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">block_device_operations</span></code> should be completed. The association
of operations is done through the <code class="xref c c-member docutils literal"><span class="pre">fops</span></code> field in the
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span></code>
structure.</p>
<p>Some of the fields of the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">block_device_operations</span></code> structure
are presented below:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">block_device_operations</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">fmode_t</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">,</span> <span class="n">fmode_t</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">locked_ioctl</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">fmode_t</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span>
                         <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ioctl</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">fmode_t</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">compat_ioctl</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">fmode_t</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span>
                         <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">direct_access</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">sector_t</span><span class="p">,</span>
                          <span class="kt">void</span> <span class="o">**</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">media_changed</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">revalidate_disk</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">getgeo</span><span class="p">)(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hd_geometry</span> <span class="o">*</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="xref c c-func docutils literal"><span class="pre">open()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">release()</span></code> operations are called directly from user
space by utilities that may perform the following tasks: partitioning, file
system creation, file system verification. In a <code class="xref c c-func docutils literal"><span class="pre">mount()</span></code> operation, the
<code class="xref c c-func docutils literal"><span class="pre">open()</span></code> function is called directly from the kernel space, the file
descriptor being stored by the kernel. A driver for a block device can not
differentiate between <code class="xref c c-func docutils literal"><span class="pre">open()</span></code> calls performed from user space and kernel
space.</p>
<p>An example of how to use these two functions is given below:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/genhd.h&gt;</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">my_block_dev</span> <span class="p">{</span>
    <span class="c1">//...</span>
    <span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span> <span class="n">gd</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="p">}</span> <span class="n">dev</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_block_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//...</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_block_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">gd</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//...</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">block_device_operations</span> <span class="n">my_block_ops</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
    <span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">my_block_open</span><span class="p">,</span>
    <span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">my_block_release</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_block_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_block_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//....</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="o">-&gt;</span><span class="n">fops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_block_ops</span><span class="p">;</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Please notice that there are no read or write operations. These operations are
performed by the <code class="xref c c-func docutils literal"><span class="pre">request()</span></code> function associated with the request queue
of the disk.</p>
</div>
<div class="section" id="request-queues">
<h2>Request queues<a class="headerlink" href="#request-queues" title="Permalink to this headline">¶</a></h2>
<p>Drivers for block devices use queues to store the block requests I/O that will
be processed. A request queue is represented by the
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span></code> structure. The request queue is made up of a
double-linked list of requests and their associated control information. The
requests are added to the queue by higher-level kernel code (for example, file
systems). As long as the request queue is not empty, the queue’s associated
driver will have to retrieve the first request from the queue and pass it to the
associated block device. Each item in the request queue is a request represented
by the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code> structure.</p>
<p>Request queues implement an interface that allows the use of multiple I/O
schedulers. A scheduler must sort the requests and present them to the driver
in order to maximize performance. The scheduler also deals with the combination
of adjacent requests (which refer to adjacent sectors of the disk).</p>
<div class="section" id="create-and-delete-a-request-queue">
<h3>Create and delete a request queue<a class="headerlink" href="#create-and-delete-a-request-queue" title="Permalink to this headline">¶</a></h3>
<p>A request queue is created with the <code class="xref c c-func docutils literal"><span class="pre">blk_init_queue()</span></code> function and is
deleted using the <code class="xref c c-func docutils literal"><span class="pre">blk_cleanup_queue()</span></code> function.</p>
<p>An example of using these functions is as follows:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/genhd.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/blkdev.h&gt;</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">my_block_dev</span> <span class="p">{</span>
    <span class="c1">//...</span>
    <span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="p">}</span> <span class="n">dev</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">my_block_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>
<span class="c1">//...</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_block_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_block_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* Initialize the I/O queue */</span>
    <span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">=</span> <span class="n">blk_init_queue</span><span class="p">(</span><span class="n">my_block_request</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
    <span class="n">blk_queue_logical_block_size</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">KERNEL_SECTOR_SIZE</span><span class="p">);</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">queuedata</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
    <span class="c1">//...</span>

<span class="nl">out_err</span><span class="p">:</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_block_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
    <span class="c1">//...</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">create_block_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">status</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">delete_block_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">)</span>
        <span class="n">blk_cleanup_queue</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">my_block_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">delete_block_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">);</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="xref c c-func docutils literal"><span class="pre">blk_init_queue()</span></code> function receives as first argument a pointer to
the function which processes the requests for the device (of type
<code class="xref c c-type docutils literal"><span class="pre">request_fn_proc</span></code>). In the example above, the function is
<code class="xref c c-func docutils literal"><span class="pre">my_block_request()</span></code>. The lock parameter is a spinlock (initialized by the
driver) that the kernel holds during the <code class="xref c c-func docutils literal"><span class="pre">request()</span></code> function call to
ensure exclusive access to the queue. This spinlock can also be used in other
driver functions to protect access to shared data with the <code class="xref c c-func docutils literal"><span class="pre">request()</span></code>
function.</p>
<p>As part of the request queue initialization, you can configure the
<code class="xref c c-member docutils literal"><span class="pre">queuedata</span></code> field, which is equivalent to the <code class="xref c c-member docutils literal"><span class="pre">private_data</span></code>
field in other structures.</p>
</div>
<div class="section" id="useful-functions-for-processing-request-queues">
<h3>Useful functions for processing request queues<a class="headerlink" href="#useful-functions-for-processing-request-queues" title="Permalink to this headline">¶</a></h3>
<p>The function of type <code class="xref c c-type docutils literal"><span class="pre">request_fn_proc</span></code> is used to handle requests for
working  with the block device. This function is the equivalent of read and
write  functions encountered on character devices. The function receives the
request queue associated with the device as an argument and can use various
functions for processing the requests from the request queue.</p>
<p>The functions used to process the requests from the request queue are
described below:</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-func docutils literal"><span class="pre">blk_peek_request()</span></code> - retrieves a reference to the first request
from the queue; the respective request must be started using
<code class="xref c c-func docutils literal"><span class="pre">blk_start_request()</span></code>;</li>
<li><code class="xref c c-func docutils literal"><span class="pre">blk_start_request()</span></code> - extracts the request from the queue and
starts it for processing; in general, the function receives as a reference
a pointer to a request returned by <code class="xref c c-func docutils literal"><span class="pre">blk_peek_request()</span></code>;</li>
<li><code class="xref c c-func docutils literal"><span class="pre">blk_fetch_request()</span></code> - retrieves the first request from the queue
(using <code class="xref c c-func docutils literal"><span class="pre">blk_peek_request()</span></code>) and starts it (using
<code class="xref c c-func docutils literal"><span class="pre">blk_start_request()</span></code>);</li>
<li><code class="xref c c-func docutils literal"><span class="pre">blk_requeue_request()</span></code> - to re-enter queue.</li>
</ul>
</div></blockquote>
<p>Before calling any of the functions above, the spinlock associated to the queue
must be acquired. If the function is called from the function of type
<code class="xref c c-type docutils literal"><span class="pre">request_fn_proc</span></code>, then the spinlock is already held.</p>
</div>
</div>
<div class="section" id="requests-for-block-devices">
<h2>Requests for block devices<a class="headerlink" href="#requests-for-block-devices" title="Permalink to this headline">¶</a></h2>
<p>A request for a block device is described by <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code>
structure.</p>
<p>The fields of <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code> structure include:</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-member docutils literal"><span class="pre">cmd_flags</span></code>: a series of flags including direction (reading or
writing); to find out the direction, the macrodefinition
<code class="xref c c-macro docutils literal"><span class="pre">rq_data_dir</span></code> is used, which returns 0 for a read request and 1
for a write request on the device;</li>
<li><code class="xref c c-member docutils literal"><span class="pre">__sector</span></code>: the first sector of the transfer request; if the
device sector has a different size, the appropriate conversion should be
done. To access this field, use the <code class="xref c c-macro docutils literal"><span class="pre">blk_rq_pos</span></code> macro;</li>
<li><code class="xref c c-member docutils literal"><span class="pre">__data_len</span></code>: the total number of bytes to be transferred; to
access this field the <code class="xref c c-macro docutils literal"><span class="pre">blk_rq_bytes</span></code> macro is used;</li>
<li>generally, data from the current <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> will be
transferred; the data size is obtained using the
<code class="xref c c-macro docutils literal"><span class="pre">blk_rq_cur_bytes</span></code> macro;</li>
<li><code class="xref c c-member docutils literal"><span class="pre">bio</span></code>, a dynamic list of <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structures that
is a set of buffers associated to the request; this field is accessed by
macrodefinition <code class="xref c c-macro docutils literal"><span class="pre">rq_for_each_segment</span></code> if there are multiple
buffers, or by <code class="xref c c-macro docutils literal"><span class="pre">bio_data</span></code> macrodefinition in case there is only
one associated buffer;</li>
<li><code class="xref c c-member docutils literal"><span class="pre">bio_data</span></code>: the address of the buffer associated to the request</li>
<li>about the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure and its associated operations
will be discussed in the ref:<cite>bio_structure</cite> section;</li>
</ul>
</div></blockquote>
<div class="section" id="create-a-request">
<h3>Create a request<a class="headerlink" href="#create-a-request" title="Permalink to this headline">¶</a></h3>
<p>Read /write requests are created by code layers superior to the kernel I/O
subsystem. Typically, the subsystem that creates requests for block devices is
the file management subsystem. The I/O subsystem acts as an interface between
the file management subsystem and the block device driver. The main operations
under the responsibility of the I/O subsystem are adding requests to the queue
of the specific block device and sorting and merging requests according to
performance considerations.</p>
</div>
<div class="section" id="finish-a-request">
<h3>Finish a request<a class="headerlink" href="#finish-a-request" title="Permalink to this headline">¶</a></h3>
<p>When the driver has finished transferring all the sectors of a request to /from
the device, it must inform the I/O subsystem by calling the
<code class="xref c c-func docutils literal"><span class="pre">blk_end_request()</span></code> function. If the lock associated to the request queue
is already acquired, the <code class="xref c c-func docutils literal"><span class="pre">__blk_end_request()</span></code> function can be used.</p>
<p>If the driver wants to close the request even if it did not transfer all the
related sectors, it can call the <code class="xref c c-func docutils literal"><span class="pre">blk_end_request_all()</span></code> or
<code class="xref c c-func docutils literal"><span class="pre">__blk_end_request_all()</span></code> function. The <code class="xref c c-func docutils literal"><span class="pre">__blk_end_request_all()</span></code>
function is called if the lock associated to the request queue is already
acquired.</p>
</div>
<div class="section" id="process-a-request">
<h3>Process a request<a class="headerlink" href="#process-a-request" title="Permalink to this headline">¶</a></h3>
<p>The central part of a block device driver is the <code class="xref c c-type docutils literal"><span class="pre">request_fn_proc</span></code>
function type. In previous examples, the function that fulfilled this role was
<code class="xref c c-func docutils literal"><span class="pre">my_block_request()</span></code>. As stated in the
<a class="reference internal" href="#create-and-delete-a-request-queue">Create and delete a request queue</a> section, this function is associated to the
driver by calling <code class="xref c c-func docutils literal"><span class="pre">blk_init_queue()</span></code> function.</p>
<p>This function is called when the kernel considers that the driver should process
I/O requests. The function must start processing the requests from the queue,
but it is not mandatory to finish them, as requests may be finished by other
parts of the driver.</p>
<p>The <code class="xref c c-data docutils literal"><span class="pre">lock</span></code> parameter, sent when creating a request queue, is a spinlock
that the kernel holds when executing the request method. For this reason, the
request function runs in an atomic context and must follow the rules for
atomic code (it does not need to call functions that can cause sleep, etc.).
This lock also ensures that no other requests for the device will be added to
the queue while the request function is running.</p>
<p>Calling the function that processes the request queue is asynchronous relative
to the actions of any userspace process and no assumptions about the process
in which the respective function is running should be made. Also, it should not
be assumed that the buffer provided by a request is from kernel space or user
space, any operation that accesses the userspace being erroneous.</p>
<p>Below is presented one of the simplest function of type
<code class="xref c c-type docutils literal"><span class="pre">request_fn_proc</span></code>:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">my_block_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">my_block_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">queuedata</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rq</span> <span class="o">=</span> <span class="n">blk_fetch_request</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rq</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">blk_rq_is_passthrough</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">printk</span> <span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;Skip non-fs request</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
            <span class="n">__blk_end_request_all</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
           <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* do work */</span>
        <span class="p">...</span>

        <span class="n">__blk_end_request_all</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="xref c c-func docutils literal"><span class="pre">my_block_request()</span></code> function contains a <code class="xref c c-func docutils literal"><span class="pre">while()</span></code> loop for
iterating through the request queue sent as argument. The operations performed
within this loop are:</p>
<blockquote>
<div><ul class="simple">
<li>Read the first request from the queue using <code class="xref c c-func docutils literal"><span class="pre">blk_fetch_request()</span></code>.
As described in <a class="reference internal" href="#useful-functions-for-processing-request-queues">Useful functions for processing request queues</a> section,
the <code class="xref c c-func docutils literal"><span class="pre">blk_fetch_request()</span></code> function retrieves the first item from the
request queue and starts the request.</li>
<li>If the function returns NULL, it has reached the end of the request queue
(there is no remaining request to be processed) and exits
<code class="xref c c-func docutils literal"><span class="pre">my_block_request()</span></code>.</li>
<li>A block device can receive calls which do not transfer data blocks (e.g.
low level operations on the disk, instructions referring to special ways of
accessing the device). Most drivers do not know how to handle these
requests and return an error.</li>
<li>To return an error, <code class="xref c c-func docutils literal"><span class="pre">__blk_end_request_all()</span></code> function is called,
-EIO being the second argument.</li>
<li>The request is processed according to the needs of the associated device.</li>
<li>The request ends. In this case, <code class="xref c c-func docutils literal"><span class="pre">__blk_end_request_all()</span></code> function is
called in order to complete the request entirely. If all request sectors
have been processed, the <code class="xref c c-func docutils literal"><span class="pre">__blk_end_request()</span></code> function is used.</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="struct-bio-structure">
<span id="bio-structure"></span><h2><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure<a class="headerlink" href="#struct-bio-structure" title="Permalink to this headline">¶</a></h2>
<p>Each <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code> structure is an I/O block request, but may come
from combining more independent requests from a higher level. The sectors to be
transferred for a request can be scattered into the main memory but they always
correspond to a set of consecutive sectors on the device. The request is
represented as a series of segments, each corresponding to a buffer in memory.
The kernel can combine requests that refer to adjacent sectors but will not
combine write requests with read requests into a single
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code> structure.</p>
<p>A <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code> structure is implemented as a linked list of
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structures together with information that allows the
driver to retain its current position while processing the request.</p>
<p>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure is a low-level description of a portion of
a block I/O request.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">bio</span> <span class="p">{</span>
    <span class="c1">//...</span>
    <span class="k">struct</span> <span class="n">block_device</span>     <span class="o">*</span><span class="n">bi_bdev</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>            <span class="n">bi_opf</span><span class="p">;</span>         <span class="cm">/* bottom bits req flags, top bits REQ_OP. Use accessors. */</span>
    <span class="c1">//...</span>
    <span class="k">struct</span> <span class="n">bio_vec</span>          <span class="o">*</span><span class="n">bi_io_vec</span><span class="p">;</span>     <span class="cm">/* the actual vec list */</span>
    <span class="c1">//...</span>
    <span class="k">struct</span> <span class="n">bvec_iter</span>        <span class="n">bi_iter</span><span class="p">;</span>
    <span class="o">/</span><span class="p">...</span>
    <span class="kt">void</span>                    <span class="o">*</span><span class="n">bi_private</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In turn, the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure contains a <code class="xref c c-member docutils literal"><span class="pre">bi_io_vec</span></code>
vector of <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio_vec</span></code> structures. It consists of the individual
pages in the physical memory to be transferred, the offset within the page and
the size of the buffer. To iterate through a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure,
we need to iterate through the vector of <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio_vec</span></code> and transfer
the data from every physical page. To simplify vector iteration, the
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bvec_iter</span></code> structure is used. This structure maintains
information about how many buffers and sectors were consumed during the
iteration. The request type is encoded in the <code class="xref c c-member docutils literal"><span class="pre">bi_opf</span></code> field; to
determine it, use the <code class="xref c c-func docutils literal"><span class="pre">bio_data_dir()</span></code> function.</p>
<div class="section" id="create-a-struct-bio-structure">
<h3>Create a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure<a class="headerlink" href="#create-a-struct-bio-structure" title="Permalink to this headline">¶</a></h3>
<p>Two functions can be used to create a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure:</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-func docutils literal"><span class="pre">bio_alloc()</span></code>: allocates space for a new structure; the structure
must be initialized;</li>
<li><code class="xref c c-func docutils literal"><span class="pre">bio_clone()</span></code>: makes a copy of an existing <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code>
structure; the newly obtained structure is initialized with the values of
the cloned structure fields; the buffers are shared with the
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure that has been cloned so that access to the
buffers has to be done carefully to avoid access to the same memory area
from the two clones;</li>
</ul>
</div></blockquote>
<p>Both functions return a new <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure.</p>
</div>
<div class="section" id="submit-a-struct-bio-structure">
<h3>Submit a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure<a class="headerlink" href="#submit-a-struct-bio-structure" title="Permalink to this headline">¶</a></h3>
<p>Usually, a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure is created by the higher levels of
the kernel (usually the file system). A structure thus created is then
transmitted to the I/O subsystem that gathers more <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code>
structures into a request.</p>
<p>For submitting a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure to the associated I/O device
driver, the <code class="xref c c-func docutils literal"><span class="pre">submit_bio()</span></code> function is used. The function receives as
argument an initialized <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure that will be added to
a request from the request queue of an I/O device. From that queue, it can be
processed by the I/O device driver using a specialized function.</p>
</div>
<div class="section" id="wait-for-the-completion-of-a-struct-bio-structure">
<span id="bio-completion"></span><h3>Wait for the completion of a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure<a class="headerlink" href="#wait-for-the-completion-of-a-struct-bio-structure" title="Permalink to this headline">¶</a></h3>
<p>Submitting a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure to a driver has the effect of
adding it to a request from the request queue from where it will be further
processed. Thus, when the <code class="xref c c-func docutils literal"><span class="pre">submit_bio()</span></code> function returns, it is not
guaranteed that the processing of the structure has finished. If you want to
wait for the processing of the request to be finished, use the
<code class="xref c c-func docutils literal"><span class="pre">submit_bio_wait()</span></code> function.</p>
<p>To be notified when the processing of a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure ends
(when we do not use <code class="xref c c-func docutils literal"><span class="pre">submit_bio_wait()</span></code> function), the
<code class="xref c c-member docutils literal"><span class="pre">bi_end_io</span></code> field of the structure should be used. This field
specifies the function that will be called at the end of the
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure processing. You can use the
<code class="xref c c-member docutils literal"><span class="pre">bi_private</span></code> field of the structure to pass information to the
function.</p>
</div>
<div class="section" id="initialize-a-struct-bio-structure">
<h3>Initialize a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure<a class="headerlink" href="#initialize-a-struct-bio-structure" title="Permalink to this headline">¶</a></h3>
<p>Once a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure has been allocated and before being
transmitted, it must be initialized.</p>
<p>Initializing the structure involves filling in its important fields. As
mentioned above, the <code class="xref c c-member docutils literal"><span class="pre">bi_end_io</span></code> field is used to specify the function
called when the processing of the structure is finished. The
<code class="xref c c-member docutils literal"><span class="pre">bi_private</span></code> field is used to store useful data that can be accessed
in the function pointed by <code class="xref c c-member docutils literal"><span class="pre">bi_end_io</span></code>.</p>
<p>The <code class="xref c c-member docutils literal"><span class="pre">bi_opf</span></code> field specifies the type of operation. Use the
<code class="xref c c-member docutils literal"><span class="pre">bio_set_op_attrs</span></code> to initialize the type of operation.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bio_alloc</span><span class="p">(</span><span class="n">GFP_NOIO</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="c1">//...</span>
<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span> <span class="o">=</span> <span class="n">bdev</span><span class="p">;</span>
<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_iter</span><span class="p">.</span><span class="n">bi_sector</span> <span class="o">=</span> <span class="n">sector</span><span class="p">;</span>
<span class="n">bio_set_op_attrs</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">REQ_OP_READ</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">bio_add_page</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
<span class="c1">//...</span>
</pre></div>
</div>
<p>In the code snippet above are specified the block device to which are sent the
following: <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure, startup sector, operation
(<code class="xref c c-data docutils literal"><span class="pre">REQ_OP_READ</span></code> or <code class="xref c c-data docutils literal"><span class="pre">REQ_OP_WRITE</span></code>) and content. The content of a
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure is a buffer described by: a physical page,
the offset in the page and the size of the bufer. A page can be assigned using
the <code class="xref c c-func docutils literal"><span class="pre">alloc_page()</span></code> call.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <code class="xref c c-data docutils literal"><span class="pre">size</span></code> field of the <code class="xref c c-func docutils literal"><span class="pre">bio_add_page()</span></code> call must be
a multiple of the device sector size.</p>
</div>
</div>
<div class="section" id="how-to-use-the-content-of-a-struct-bio-structure">
<span id="bio-content"></span><h3>How to use the content of a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure<a class="headerlink" href="#how-to-use-the-content-of-a-struct-bio-structure" title="Permalink to this headline">¶</a></h3>
<p>To use the content of a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure, the structure’s
support pages must be mapped to the kernel address space from where they can be
accessed. For mapping /unmapping, use the <code class="xref c c-macro docutils literal"><span class="pre">kmap_atomic</span></code> and
the <code class="xref c c-macro docutils literal"><span class="pre">kunmap_atomic</span></code> macros.</p>
<p>A typical example of use is:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">my_block_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_block_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">start</span><span class="p">,</span>
                              <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_xfer_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_block_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">bio_vec</span> <span class="n">bvec</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">bvec_iter</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">bio_data_dir</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>

    <span class="cm">/* Do each segment independently. */</span>
    <span class="n">bio_for_each_segment</span><span class="p">(</span><span class="n">bvec</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sector_t</span> <span class="n">sector</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">bi_sector</span><span class="p">;</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">bvec</span><span class="p">.</span><span class="n">bv_page</span><span class="p">);</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">bvec</span><span class="p">.</span><span class="n">bv_offset</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">bvec</span><span class="p">.</span><span class="n">bv_len</span><span class="p">;</span>

        <span class="cm">/* process mapped buffer */</span>
        <span class="n">my_block_transfer</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sector</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">buffer</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>

        <span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As it can be seen from the example above, iterating through a
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> requires iterating through all of its segments. A segment
(<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio_vec</span></code>) is defined by the physical address page, the offset
in the page and its size.</p>
<p>To simplify the processing of a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code>, use the
<code class="xref c c-macro docutils literal"><span class="pre">bio_for_each_segment</span></code> macrodefinition. It will iterate through all
segments, and will also update global information stored in an iterator
(<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bvec_iter</span></code>) such as the current sector as well as other
internal information (segment vector index, number of bytes left to be
processed, etc.) .</p>
<p>It can store information in the mapped buffer, or extract information.</p>
<p>In the case request queues are used and it is needed to process the requests
at <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> level, use the <code class="xref c c-macro docutils literal"><span class="pre">rq_for_each_segment</span></code>
macrodefinition instead of the <code class="xref c c-macro docutils literal"><span class="pre">bio_for_each_segment</span></code> macrodefinition.
This macrodefinition iterates through each segment of each
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure of a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code> structure and
updates a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">req_iterator</span></code> structure. The
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">req_iterator</span></code> contains the current <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code>
structure and the iterator that traverses its segments.</p>
<p>A typical example of use is:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">bio_vec</span> <span class="n">bvec</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">req_iterator</span> <span class="n">iter</span><span class="p">;</span>

<span class="n">rq_for_each_segment</span><span class="p">(</span><span class="n">bvec</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sector_t</span> <span class="n">sector</span> <span class="o">=</span> <span class="n">iter</span><span class="p">.</span><span class="n">iter</span><span class="p">.</span><span class="n">bi_sector</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">bvec</span><span class="p">.</span><span class="n">bv_page</span><span class="p">);</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">bvec</span><span class="p">.</span><span class="n">bv_offset</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">bvec</span><span class="p">.</span><span class="n">bv_len</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">bio_data_dir</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">bio</span><span class="p">);</span>

    <span class="n">my_block_transfer</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sector</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">buffer</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>

    <span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="free-a-struct-bio-structure">
<h3>Free a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure<a class="headerlink" href="#free-a-struct-bio-structure" title="Permalink to this headline">¶</a></h3>
<p>Once a kernel subsystem uses a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure, it will have to
release the reference to it. This is done by calling <code class="xref c c-func docutils literal"><span class="pre">bio_put()</span></code> function.</p>
</div>
<div class="section" id="set-up-a-request-queue-at-struct-bio-level">
<h3>Set up a request queue at <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> level<a class="headerlink" href="#set-up-a-request-queue-at-struct-bio-level" title="Permalink to this headline">¶</a></h3>
<p>The function <code class="xref c c-func docutils literal"><span class="pre">blk_init_queue()</span></code> may specify a function to be used to
process requests sent to the driver. The function receives as argument the
request queue as queries and carries out processing at
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code> level.</p>
<p>If, for flexibility reasons, it is needed to specify a function that carries
out processing at <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure level, the function
<code class="xref c c-func docutils literal"><span class="pre">blk_queue_make_request()</span></code> in conjunction with the
<code class="xref c c-func docutils literal"><span class="pre">blk_alloc_queue()</span></code> function should be used.</p>
<p>Below is a typical example of initializing a function that carries out
processing at <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure level:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="c1">// the declaration of the function that carries out processing</span>
<span class="c1">// :c:type:`struct bio` structures</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">my_make_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">);</span>


<span class="c1">// ...</span>
<span class="c1">// queue creation</span>
<span class="n">dev</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">=</span> <span class="n">blk_alloc_queue</span> <span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;cannot allocate block device queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// the registration of the function that carries out processing</span>
<span class="c1">// :c:type:`struct bio` structures</span>
<span class="n">blk_queue_make_request</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">my_make_request</span><span class="p">);</span>
<span class="n">dev</span><span class="o">-&gt;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">queuedata</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="further-reading">
<h2>Further reading<a class="headerlink" href="#further-reading" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference external" href="http://static.lwn.net/images/pdf/LDD3/ch16.pdf">Linux Device Drivers 3rd Edition, Chapter 16. Block Drivers</a></li>
<li>Linux Kernel Development, Second Edition – Chapter 13. The Block I/O Layer</li>
<li><a class="reference external" href="https://lwn.net/Articles/58719/">A simple block driver</a></li>
<li><a class="reference external" href="https://lwn.net/Articles/25711/">The gendisk interface</a></li>
<li><a class="reference external" href="https://lwn.net/Articles/26404/">The bio structure</a></li>
<li><a class="reference external" href="https://lwn.net/Articles/27055/">Request queues</a></li>
<li><a class="reference external" href="https://elixir.bootlin.com/linux/v4.15/source/Documentation/block/request.txt">Documentation/block/request.txt - Struct request documentation</a></li>
<li><a class="reference external" href="https://elixir.bootlin.com/linux/v4.15/source/Documentation/block/biodoc.txt">Documentation/block/biodoc.txt - Notes on the Generic Block Layer</a></li>
<li><a class="reference external" href="https://elixir.bootlin.com/linux/v4.15/source/drivers/block/brd.c">drivers/block/brd/c - RAM backed block disk driver</a></li>
<li><a class="reference external" href="https://www.linuxjournal.com/article/6931">I/O Schedulers</a></li>
</ul>
</div>
<div class="section" id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p>To solve exercises, you need to perform these steps:</p>
<blockquote>
<div><ul class="simple">
<li>prepare skeletons from templates</li>
<li>build modules</li>
<li>copy modules to the VM</li>
<li>start the VM and test the module in the VM.</li>
</ul>
</div></blockquote>
<p>The current lab name is block_device_drivers. See the exercises for the task name.</p>
<div class="toggle last docutils container">
<div class="header docutils container">
<strong>See details</strong></div>
<p>The skeleton code is generated from full source examples located in
<code class="file docutils literal"><span class="pre">tools/labs/templates</span></code>. To solve the tasks, start by generating
the skeleton code:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make clean
tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt;/&lt;task name&gt; make skels
</pre></div>
</div>
<p>where task name is defined for each task. Once the skeleton drivers are
generated, build the source:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make build
</pre></div>
</div>
<p>Then, copy the modules and start the VM:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make copy
tools/labs $ make boot
</pre></div>
</div>
<p>The modules are placed in /home/root/skels/block_device_drivers/&lt;task_name&gt;.</p>
<p>Alternatively, we can copy files via <strong class="command">scp</strong>, in order to avoid restarting the VM.
For additional details about connecting to the VM via the network, please check <a class="reference internal" href="vm.html#vm-interaction-link"><span class="std std-ref">Connecting to the VM</span></a>.</p>
<p>Review the <a class="reference internal" href="#exercises">Exercises</a> section for more detailed information.</p>
</div>
</div>
<div class="section" id="intro">
<h3>0. Intro<a class="headerlink" href="#intro" title="Permalink to this headline">¶</a></h3>
<p>Using <a class="reference external" href="http://elixir.free-electrons.com/linux/latest/source">LXR</a> find the definitions of the following symbols in the Linux kernel:</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code></li>
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio_vec</span></code></li>
<li><code class="xref c c-macro docutils literal"><span class="pre">bio_for_each_segment</span></code></li>
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span></code></li>
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">block_device_operations</span></code></li>
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="block-device">
<h3>1. Block device<a class="headerlink" href="#block-device" title="Permalink to this headline">¶</a></h3>
<p>Create a kernel module that allows you to register or deregister a block device.
Start from the files in the <code class="file docutils literal"><span class="pre">1-2-3-6-ram-disk/kernel</span></code> directory in the
labs task archive.</p>
<p>Follow the comments marked with <strong>TODO 1</strong> in the laboratory skeleton. Use the
existing macrodefinitions (<code class="xref c c-macro docutils literal"><span class="pre">MY_BLOCK_MAJOR</span></code>,
<code class="xref c c-macro docutils literal"><span class="pre">MY_BLKDEV_NAME</span></code>). Check the value returned by the register function,
and in case of error, return the error code.</p>
<p>Compile the module, copy it to the virtual machine and insert it into the
kernel. Verify that your device was successfully created inside the
<code class="file docutils literal"><span class="pre">/proc/devices</span></code>.
You will see a device with major 240.</p>
<p>Unload the kernel module and check that the device was unregistered.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">Review the <a class="reference internal" href="#register-a-block-i-o-device">Register a block I/O device</a> section.</p>
</div>
<p>Change the <code class="xref c c-macro docutils literal"><span class="pre">MY_BLOCK_MAJOR</span></code> value to 7. Compile the module, copy it to
the virtual machine, and insert it into the kernel. Notice that the insertion
fails because there is already another driver /device registered in the kernel
with the major 7.</p>
<p>Restore the 240 value for the <code class="xref c c-macro docutils literal"><span class="pre">MY_BLOCK_MAJOR</span></code> macro.</p>
</div>
<div class="section" id="disk-registration">
<h3>2. Disk registration<a class="headerlink" href="#disk-registration" title="Permalink to this headline">¶</a></h3>
<p>Modify the previous module to add a disk associated with the driver. Analyze the
macrodefinitions, <code class="xref c c-type docutils literal"><span class="pre">my_block_dev</span></code> structure and existing functions from
the <code class="file docutils literal"><span class="pre">ram-disk.c</span></code> file.</p>
<p>Follow the comments marked with <strong>TODO 2</strong>. Use the
<code class="xref c c-func docutils literal"><span class="pre">create_block_device()</span></code> and the <code class="xref c c-func docutils literal"><span class="pre">delete_block_device()</span></code> functions.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">Review the <a class="reference internal" href="#register-a-disk">Register a disk</a> and <a class="reference internal" href="#process-a-request">Process a request</a> sections.</p>
</div>
<p>Complete the <code class="xref c c-func docutils literal"><span class="pre">my_block_request()</span></code> function to process the request queue
without actually processing your request: display the “request received” message
and the following information: start sector, total size, data size from the
current <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure, direction. To validate a request type,
use the <code class="xref c c-func docutils literal"><span class="pre">blk_rq_is_passthrough()</span></code> (the function returns 0 in the case in
which we are interested, i.e. when the request is generated by the file system).</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">To retrieve the needed info, review the <a class="reference internal" href="#requests-for-block-devices">Requests for block devices</a>
section.</p>
</div>
<p>Use the <code class="xref c c-func docutils literal"><span class="pre">__blk_end_request_all()</span></code> function to finish processing the
request.</p>
<p>Insert the module into the kernel. Use <strong class="command">dmesg</strong> to view a message sent
by the module. When a device is added, a request is sent to the device. Check
the presence of <code class="file docutils literal"><span class="pre">/dev/myblock</span></code> and if it doesn’t exist, create the device
using the command:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>mknod /dev/myblock b <span class="m">240</span> <span class="m">0</span>
</pre></div>
</div>
<p>To generate writing requests, use the command:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span><span class="nb">echo</span> <span class="s2">&quot;abc&quot;</span>&gt; /dev/myblock
</pre></div>
</div>
<p>Notice that is created a write request preceded by a read request. The read
request takes place to read the block from the disk and “update” in its content
what it was provided by the user without overwriting the rest. After reading and
updating, writing takes place.</p>
</div>
<div class="section" id="ram-disk">
<h3>3. RAM disk<a class="headerlink" href="#ram-disk" title="Permalink to this headline">¶</a></h3>
<p>Modify the previous module to create a RAM disk: requests to the device will
result in read/write in a memory area.</p>
<p>The memory area <code class="xref c c-data docutils literal"><span class="pre">dev-&gt;data</span></code> is already allocated in the source code of
the module using <code class="xref c c-func docutils literal"><span class="pre">vmalloc()</span></code>. To deallocate, use <code class="xref c c-func docutils literal"><span class="pre">vfree()</span></code>.</p>
<p>..note:: Review the <a class="reference internal" href="#process-a-request">Process a request</a> section.</p>
<p>Follow the comments marked with <strong>TODO 3</strong> to complete the
<code class="xref c c-func docutils literal"><span class="pre">my_block_transfer()</span></code> function to write /read the request information
in /from the memory area. The function will be called for each request within
the queue processing function: <code class="xref c c-func docutils literal"><span class="pre">my_block_request()</span></code>. To write /read
in /from the memory area use <code class="xref c c-func docutils literal"><span class="pre">memcpy()</span></code>. To determine the write /read
information, use the fields of the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code> structure.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">To find out the size of the request data, use the
<code class="xref c c-macro docutils literal"><span class="pre">blk_rq_cur_bytes</span></code> macro. Do not use the
<code class="xref c c-macro docutils literal"><span class="pre">blk_rq_bytes</span></code> macro.</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">To find out the buffer associated to the request, use
<code class="xref c c-data docutils literal"><span class="pre">bio_data</span></code> (<code class="xref c c-data docutils literal"><span class="pre">rq-&gt;bio</span></code>).</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">A description of useful macros is in the <a class="reference internal" href="#requests-for-block-devices">Requests for block devices</a>
section.</p>
</div>
<p>Useful information can be found in the example of the block device driver in
Linux Device Drivers.</p>
<p>For testing, use the <code class="file docutils literal"><span class="pre">ram-disk-test.c</span></code> test file. You compile it using on
the host, the command:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>make -f Makefile.test
</pre></div>
</div>
<p>and then run it using the QEMU virtual machine command:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>./ram-disk-test
</pre></div>
</div>
<p>There is no need to insert the module into the kernel, it will be inserted by
the <strong class="command">ram-disk-test</strong> executable.</p>
<p>Some tests may crash because of lack of synchronization between the transmitted
data (flush).</p>
</div>
<div class="section" id="read-data-from-the-disk">
<h3>4. Read data from the disk<a class="headerlink" href="#read-data-from-the-disk" title="Permalink to this headline">¶</a></h3>
<p>The purpose of this exercise is to read data from the
<code class="xref c c-macro docutils literal"><span class="pre">PHYSICAL_DISK_NAME</span></code> disk (<code class="file docutils literal"><span class="pre">/dev/vdb</span></code>) directly from the kernel.</p>
<div class="admonition attention">
<p class="first admonition-title">Attention</p>
<p>Before solving the exercise, we need to add the disk to the
virtual machine. To do this, generate a file that we will use as
the disk image using the command:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<p>dd if=/dev/zero of=qemu/mydisk.img bs=1024 count=1</p>
<p class="last">and add the command:
<strong class="command">-drive file = qemu/mydisk.img, if=virtio, format=raw
qemu</strong>
in the <code class="file docutils literal"><span class="pre">qemu/Makefile</span></code> file (in the
<code class="xref c c-data docutils literal"><span class="pre">QEMU_OPTS</span></code> variable)</p>
</div>
<p>Follow the comments marked with <strong>TODO 4</strong> in the directory <code class="file docutils literal"><span class="pre">4-5-relay/</span></code>
and implement the <code class="xref c c-func docutils literal"><span class="pre">open_disk()</span></code> and the <code class="xref c c-func docutils literal"><span class="pre">close_disk()</span></code> functions.
Use the <code class="xref c c-func docutils literal"><span class="pre">blkdev_get_by_path()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">blkdev_put()</span></code> functions. The
device must be opened in read-write mode exclusively
(<code class="xref c c-macro docutils literal"><span class="pre">FMODE_READ</span></code> | <code class="xref c c-macro docutils literal"><span class="pre">FMODE_WRITE</span></code> | <code class="xref c c-macro docutils literal"><span class="pre">FMODE_EXCL</span></code>), and
as holder you must use the current module (<code class="xref c c-macro docutils literal"><span class="pre">THIS_MODULE</span></code>).</p>
<p>Implement the <code class="xref c c-func docutils literal"><span class="pre">send_test_bio()</span></code> function. You will have to create a new
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure and fill it, submit it and wait for it. Read the
first sector of the disk. To wait, call the <code class="xref c c-func docutils literal"><span class="pre">submit_bio_wait()</span></code> function.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">The first sector of the disk is the sector with the index 0. At this
value the field <code class="xref c c-member docutils literal"><span class="pre">bi_iter.bi_sector</span></code> of the
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure must be initialized.</p>
</div>
<p>For the read operation, use the <code class="xref c c-macro docutils literal"><span class="pre">REQ_OP_READ</span></code> and the
<code class="xref c c-macro docutils literal"><span class="pre">bio_set_op_attrs</span></code> macros.</p>
<p>After finishing the operation, display the first 3 bytes of data read by
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure. Use the format “% 02x” for the <code class="xref c c-func docutils literal"><span class="pre">printk()</span></code>
to display the data and the <code class="xref c c-macro docutils literal"><span class="pre">kmap_atomic</span></code> and <code class="xref c c-macro docutils literal"><span class="pre">kunmap_atomic</span></code>
macros respectively.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">As an argument for the <code class="xref c c-func docutils literal"><span class="pre">kmap_atomic()</span></code> function, just use the
page which is allocated above in the code, in the <code class="xref c c-data docutils literal"><span class="pre">page</span></code>
variable.</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">Review the sections ref:<cite>bio_content</cite> and ref:<cite>bio_completion</cite>.</p>
</div>
<p>For testing, use the <code class="file docutils literal"><span class="pre">test-relay-disk</span></code> script, which is copied on the
virtual machine when running <strong class="command">make copy</strong>. If it is not copied, make
sure it is executable:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>chmod +x test-relay-disk
</pre></div>
</div>
<p>There is no need to load the module into the kernel, it will be loaded by the
<strong class="command">test-relay-disk</strong>.</p>
<p>Use the command below to run the script:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>./test-relay-disk
</pre></div>
</div>
<p>The script writes “abc” at the beginning of the disk indicated by
<code class="xref c c-macro docutils literal"><span class="pre">PHYSICAL_DISK_NAME</span></code>. After running, the module will display 61 62 63
(the corresponding hexadecimal values of letters “a”, “b” and “c”).</p>
</div>
<div class="section" id="write-data-to-the-disk">
<h3>5. Write data to the disk<a class="headerlink" href="#write-data-to-the-disk" title="Permalink to this headline">¶</a></h3>
<p>Follow the comments marked with <strong>TODO 5</strong> to write a message
(<code class="xref c c-macro docutils literal"><span class="pre">BIO_WRITE_MESSAGE</span></code>) on the disk.</p>
<p>The <code class="xref c c-func docutils literal"><span class="pre">send_test_bio()</span></code> function receives as argument the operation type
(read or write). Call in the <code class="xref c c-func docutils literal"><span class="pre">relay_init()</span></code> function the function for
reading and in the <code class="xref c c-func docutils literal"><span class="pre">relay_exit()</span></code> function the function for writing. We
recommend using the <code class="xref c c-macro docutils literal"><span class="pre">REQ_OP_READ</span></code> and the <code class="xref c c-macro docutils literal"><span class="pre">REQ_OP_WRITE</span></code>
macros.</p>
<p>Inside the <code class="xref c c-func docutils literal"><span class="pre">send_test_bio()</span></code> function, if the operation is write, fill in
the buffer associated to the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure with the message
<code class="xref c c-macro docutils literal"><span class="pre">BIO_WRITE_MESSAGE</span></code>. Use the <code class="xref c c-macro docutils literal"><span class="pre">kmap_atomic</span></code> and the
<code class="xref c c-macro docutils literal"><span class="pre">kunmap_atomic</span></code> macros to work with the buffer associated to the
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">You need to update the type of the operation associated to the
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure operation using
<code class="xref c c-macro docutils literal"><span class="pre">bio_set_op_attrs</span></code> macrodefinition.</p>
</div>
<p>For testing, run the <code class="file docutils literal"><span class="pre">test-relay-disk</span></code> script using the command:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>./test-relay-disk
</pre></div>
</div>
<p>The script will display the “read from /dev/sdb: 64 65 66” message at the
standard output.</p>
</div>
<div class="section" id="processing-requests-from-the-request-queue-at-struct-bio-level">
<h3>6. Processing requests from the request queue at <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> level<a class="headerlink" href="#processing-requests-from-the-request-queue-at-struct-bio-level" title="Permalink to this headline">¶</a></h3>
<p>In the implementation from Exercise 3, we have only processed a
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio_vec</span></code> of the current <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> from the request.
We want to process all <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio_vec</span></code> structures from all
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structures.
For this, we will iterate through all <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> requests and through
all <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio_vec</span></code> structures (also called segments) of each
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code>.</p>
<p>Add, within the ramdisk implementation (<code class="file docutils literal"><span class="pre">1-2-3-6-ram-disk/</span></code> directory),
support for processing the requests from the request queue at
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> level. Follow the comments marked with <strong>TODO 6</strong>.</p>
<p>Set the <code class="xref c c-macro docutils literal"><span class="pre">USE_BIO_TRANSFER</span></code> macro to 1.</p>
<p>Implement the <code class="xref c c-func docutils literal"><span class="pre">my_xfer_request()</span></code> function. Use the
<code class="xref c c-macro docutils literal"><span class="pre">rq_for_each_segment</span></code> macro to iterate through the <code class="xref c c-type docutils literal"><span class="pre">bio_vec</span></code>
structures of each <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> from the request.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">Review the indications and the code snippets from the
<a class="reference internal" href="#bio-content"><span class="std std-ref">How to use the content of a struct bio structure</span></a> section.</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">Use the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> segment iterator to get the current
sector (<code class="xref c c-member docutils literal"><span class="pre">iter.iter.bi_sector</span></code>).</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">Use the request iterator to get the reference to the current
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> (<code class="xref c c-member docutils literal"><span class="pre">iter.bio</span></code>).</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">Use the <code class="xref c c-macro docutils literal"><span class="pre">bio_data_dir</span></code> macro to find the reading or writing
direction for a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code>.</p>
</div>
<p>Use the <code class="xref c c-macro docutils literal"><span class="pre">kmap_atomic</span></code> or the <code class="xref c c-macro docutils literal"><span class="pre">kunmap_atomic</span></code> macros to map
the pages of each <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure and access its associated
buffers. For the actual transfer, call the <code class="xref c c-func docutils literal"><span class="pre">my_block_transfer()</span></code> function
implemented in the previous exercise.</p>
<p>For testing, use the <code class="file docutils literal"><span class="pre">ram-disk-test.c</span></code> test file. You compile it using on
the host, the command:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>make -f Makefile.test
</pre></div>
</div>
<p>and then run it using the QEMU virtual machine command:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>./ram-disk-test
</pre></div>
</div>
<p>There is no need to insert the module into the kernel, it will be inserted by
the <strong class="command">ram-disk-test</strong> executable.</p>
<p>Some tests may crash because of lack of synchronization between the transmitted
data (flush).</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="memory_mapping.html" class="btn btn-neutral float-right" title="Memory mapping" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="deferred_work.html" class="btn btn-neutral" title="Deferred work" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/asciinema-player.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script> 

</body>
</html>